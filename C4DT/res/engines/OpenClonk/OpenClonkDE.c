static const int C4D_All;
static const int C4D_Background;
static const int C4D_Goal;
static const int C4D_Living;
static const int C4D_Object;
static const int C4D_Parallax;
static const int C4D_Rule;
static const int C4D_StaticBack;
static const int C4D_Structure;
static const int C4D_Vehicle;
static const int C4V_Array;
static const int C4V_Bool;
static const int C4V_C4Object;
static const int C4V_Int;
static const int C4V_Nil;
static const int C4V_PropList;
static const int C4V_String;
static const int COMD_Down;
static const int COMD_DownLeft;
static const int COMD_DownRight;
static const int COMD_Left;
static const int COMD_None;
static const int COMD_Right;
static const int COMD_Stop;
static const int COMD_Up;
static const int COMD_UpLeft;
static const int COMD_UpRight;
static const int DIR_Left;
static const int DIR_Right;
static const int NO_OWNER;
static const int OCF_Alive;
static const int OCF_AttractLightning;
static const int OCF_Available;
static const int OCF_Chop;
static const int OCF_Collectible;
static const int OCF_Collection;
static const int OCF_Construct;
static const int OCF_Container;
static const int OCF_CrewMember;
static const int OCF_Entrance;
static const int OCF_Exclusive;
static const int OCF_Fullcon;
static const int OCF_Grab;
static const int OCF_HitSpeed1;
static const int OCF_HitSpeed2;
static const int OCF_HitSpeed3;
static const int OCF_HitSpeed4;
static const int OCF_Inflammable;
static const int OCF_InFree;
static const int OCF_InLiquid;
static const int OCF_InSolid;
static const int OCF_Living;
static const int OCF_NotContained;
static const int OCF_OnFire;
static const int OCF_Rotate;
static const int this;
static const int C4V_Effect;
static const int C4V_Def;
static const int C4V_Function;
static const int C4X_Ver1;
static const int C4X_Ver2;
static const int C4X_Ver3;
static const int FX_OK;
static const int FX_Effect_Deny;
static const int FX_Effect_Annul;
static const int FX_Effect_AnnulDoCalls;
static const int FX_Execute_Kill;
static const int FX_Stop_Deny;
static const int FX_Start_Deny;
static const int FX_Call_Normal;
static const int FX_Call_Temp;
static const int FX_Call_TempAddForRemoval;
static const int FX_Call_RemoveClear;
static const int FX_Call_RemoveDeath;
static const int FX_Call_DmgScript;
static const int FX_Call_DmgBlast;
static const int FX_Call_DmgFire;
static const int FX_Call_Energy;
static const int FX_Call_EngScript;
static const int FX_Call_EngBlast;
static const int FX_Call_EngObjHit;
static const int FX_Call_EngFire;
static const int FX_Call_EngBaseRefresh;
static const int FX_Call_EngAsphyxiation;
static const int FX_Call_EngCorrosion;
static const int FX_Call_EngGetPunched;
static const int C4M_Vehicle;
static const int C4M_Solid;
static const int C4M_SemiSolid;
static const int C4M_Liquid;
static const int C4M_Background;
static const int SBRD_Caption;
static const int TEAM_Custom;
static const int TEAM_Active;
static const int TEAM_AllowHostilityChange;
static const int TEAM_Dist;
static const int TEAM_AllowTeamSwitch;
static const int TEAM_AutoGenerateTeams;
static const int TEAM_TeamColors;
static const int C4FO_Not;
static const int C4FO_And;
static const int C4FO_Or;
static const int C4FO_Exclude;
static const int C4FO_InRect;
static const int C4FO_AtPoint;
static const int C4FO_AtRect;
static const int C4FO_OnLine;
static const int C4FO_Distance;
static const int C4FO_ID;
static const int C4FO_OCF;
static const int C4FO_Category;
static const int C4FO_Action;
static const int C4FO_ActionTarget;
static const int C4FO_Procedure;
static const int C4FO_Container;
static const int C4FO_AnyContainer;
static const int C4FO_Owner;
static const int C4FO_Controller;
static const int C4FO_Func;
static const int C4FO_Layer;
static const int MD_DragSource;
static const int MD_DropTarget;
static const int MD_NoClick;
static const int C4SO_Reverse;
static const int C4SO_Multiple;
static const int C4SO_Distance;
static const int C4SO_Random;
static const int C4SO_Speed;
static const int C4SO_Mass;
static const int C4SO_Value;
static const int C4SO_Func;
static const int C4SECT_SaveLandscape;
static const int C4SECT_SaveObjects;
static const int C4SECT_KeepEffects;
static const int TEAMID_New;
static const int MSG_NoLinebreak;
static const int MSG_Bottom;
static const int MSG_Multiple;
static const int MSG_Top;
static const int MSG_Left;
static const int MSG_Right;
static const int MSG_HCenter;
static const int MSG_VCenter;
static const int MSG_DropSpeech;
static const int MSG_WidthRel;
static const int MSG_XRel;
static const int MSG_YRel;
static const int C4PT_User;
static const int C4PT_Script;
static const int CSPF_FixedAttributes;
static const int CSPF_NoScenarioInit;
static const int CSPF_NoEliminationCheck;
static const int CSPF_Invisible;
static const int DMQ_Sky;
static const int DMQ_Sub;
static const int DMQ_Bridge;
static const int PLRZOOM_Direct;
static const int PLRZOOM_NoIncrease;
static const int PLRZOOM_NoDecrease;
static const int PLRZOOM_LimitMin;
static const int PLRZOOM_LimitMax;
static const int C4D_Environment;
static const int C4D_MouseSelect;
static const int C4D_Foreground;
static const int C4D_MouseIgnore;
static const int C4D_IgnoreFoW;
static const int C4D_GrabGet;
static const int C4D_GrabPut;
static const int VIS_All;
static const int VIS_None;
static const int VIS_Owner;
static const int VIS_Allies;
static const int VIS_Enemies;
static const int VIS_Select;
static const int VIS_God;
static const int VIS_LayerToggle;
static const int VIS_OverlayOnly;
static const int C4MN_Style_Normal;
static const int C4MN_Style_Context;
static const int C4MN_Style_Info;
static const int C4MN_Style_Dialog;
static const int C4MN_Style_EqualItemHeight;
static const int C4MN_Extra_None;
static const int C4MN_Extra_Components;
static const int C4MN_Extra_Value;
static const int C4MN_Extra_Info;
static const int C4MN_Add_ImgRank;
static const int C4MN_Add_ImgIndexed;
static const int C4MN_Add_ImgObjRank;
static const int C4MN_Add_ImgObject;
static const int C4MN_Add_ImgTextSpec;
static const int C4MN_Add_ImgColor;
static const int C4MN_Add_PassValue;
static const int C4MN_Add_ForceCount;
static const int C4MN_Add_ForceNoDesc;
static const int GFXOV_MODE_None;
static const int GFXOV_MODE_Base;
static const int GFXOV_MODE_Action;
static const int GFXOV_MODE_Picture;
static const int GFXOV_MODE_IngamePicture;
static const int GFXOV_MODE_Object;
static const int GFXOV_MODE_ExtraGraphics;
static const int GFXOV_MODE_Rank;
static const int GFXOV_MODE_ObjectPicture;
static const int GFX_Overlay;
static const int GFXOV_Clothing;
static const int GFXOV_Tools;
static const int GFXOV_ProcessTarget;
static const int GFXOV_Misc;
static const int GFXOV_UI;
static const int GFX_BLIT_Additive;
static const int GFX_BLIT_Mod2;
static const int GFX_BLIT_ClrSfc_OwnClr;
static const int GFX_BLIT_ClrSfc_Mod2;
static const int GFX_BLIT_Wireframe;
static const int GFX_BLIT_Custom;
static const int GFX_BLIT_Parent;
static const int CNAT_None;
static const int CNAT_Left;
static const int CNAT_Right;
static const int CNAT_Top;
static const int CNAT_Bottom;
static const int CNAT_Center;
static const int CNAT_MultiAttach;
static const int CNAT_NoCollision;
static const int VTX_X;
static const int VTX_Y;
static const int VTX_CNAT;
static const int VTX_Friction;
static const int VTX_SetPermanent;
static const int VTX_SetPermanentUpd;
static const int C4OS_DELETED;
static const int C4OS_NORMAL;
static const int C4OS_INACTIVE;
static const int C4CMD_Base;
static const int C4CMD_SilentBase;
static const int C4CMD_Sub;
static const int C4CMD_SilentSub;
static const int C4CMD_MoveTo_NoPosAdjust;
static const int C4CMD_MoveTo_PushTarget;
static const int C4CMD_Enter_PushTarget;
static const int C4AVP_Const;
static const int C4AVP_Linear;
static const int C4AVP_X;
static const int C4AVP_Y;
static const int C4AVP_R;
static const int C4AVP_AbsX;
static const int C4AVP_AbsY;
static const int C4AVP_XDir;
static const int C4AVP_YDir;
static const int C4AVP_RDir;
static const int C4AVP_CosR;
static const int C4AVP_SinR;
static const int C4AVP_CosV;
static const int C4AVP_SinV;
static const int C4AVP_Action;
static const int ANIM_Loop;
static const int ANIM_Hold;
static const int ANIM_Remove;
static const int AM_None;
static const int AM_DrawBefore;
static const any nil;

//Ruft die überladene Funktion auf. Funktionen überladen sich, wenn sie beide den gleichen Namen haben. Die Funktion ist im Gegensatz zu <funclink>inherited<funclink/> außerdem failsafe. Das heißt, dass es zu keinem Fehler führt, wenn die Ursprungsfunktion gar nicht existiert.
global func any _inherited();
//Bildet den Absolutwert (Betrag), entfernt also das Vorzeichen des ersten Parameters.
global func int Abs(/* Wert, von dem der absolutwert gebildet werden soll*/ int value);
//Liefert das relative X in Bezug auf Objektmitte wenn von einem Objekt aufgerufen. Sonst liefert diese Funktion das übergebene X zurück
global func int AbsX(/* X*/ int x);
//Liefert das relative Y in Bezug auf Objektmitte wenn von einem Objekt aufgerufen. Sonst liefert diese Funktion das übergebene Y zurück
global func int AbsY(/* Y*/ int y);
//Prüft, ob das aufrufende Objekt eine Aktivität ausführt.
global func bool ActIdle();
//Fügt ein Kommado in die Kommandoliste des aufrufenden Objekts hinzu (an den Anfang, siehe auch <funclink>AppendCommand<funclink/>). D.h. es wird ein Kommando hinzugefügt, welches das Objekt vor anderen vorher gegebenen Kommandos auszuführen hat (war vorher kein Kommando gesetzt, so entspricht AddCommand <funclink>SetCommand<funclink/>) <br><br/> Für Kommando-Beschreibungen siehe <funclink>SetCommand<funclink/>
global func bool AddCommand(/* Kommandoname (als String). Siehe untere Tabelle*/ string command, /* Zielobjekt für Aktion*/ object target, /* X-Zielkoordinate*/ int x, /* Y-Zielkoordinate*/ int y, /* zweites Zielobjekt*/ object target2, /* Zeit (in Ticks/Frames), bis das Kommando abgebrochen wird (es wird dann mit dem nachsten in der Kommandoliste fortgesetzt)*/ int delay, /* zusätzliche Daten zur Aktion*/ Data, /* Anzahl der Wiederholungen (wenn das Kommando fehlschlägt), bis das Kommando abgebrochen wird.*/ int retries, /* 
            Determines the behaviour if the command fails.<br><br/><br><br/>
            <table>
              <rowh>
                <col>base_mode<col/>
                <col>Name<col/>
                <col>Beschreibung<col/>
                <col>Fehlschlagsmeldung und CallFailed-Aufrufe<col/>
                <col>Nächster Befehl<col/>
              <rowh/>
              <row>
                <col>0<col/>
                <col>C4CMD_SilentSub<col/>
                <col>Stiller Unterbefehl<col/>
                <col>Nur wenn dies der letzte Befehl ist<col/>
                <col>Schlägt fehl<col/>
              <row/>
              <row>
                <col>3<col/>
                <col>C4CMD_Sub<col/>
                <col>Unterbefehl<col/>
                <col>Wenn der nächste Befehl keine Wiederholungen mehr hat oder dies der letzte Befehl ist<col/>
                <col>Schlägt fehl<col/>
              <row/>
              <row>
                <col>2<col/>
                <col>C4CMD_SilentBase<col/>
                <col>Stiller Basisbefehl<col/>
                <col>Nie<col/>
                <col>Schlägt nicht fehl<col/>
              <row/>
              <row>
                <col>1<col/>
                <col>C4CMD_Base<col/>
                <col>Basisbefehl<col/>
                <col>Immer<col/>
                <col>Schlägt nicht fehl<col/>
              <row/>
            <table/>

          */ int base_mode);
//Erzeugt einen Effekt. Rückgabewert ist der Effekt bei Erfolg, oder <code>nil<code/> bei Fehlschlag (weil der Effekt beispielsweise abgelehnt wurde). Wenn der Effekt von einem anderen Effekt aufgenommen wurde, der sich in demselben Aufruf entfernt, wird wahrscheinlich <code>nil<code/> zurückgegeben.
global func proplist AddEffect(/* Name des Effektes ohne vorangestelltes Fx.*/ string name, /* Zielobjekt für den Effekt. Bei <code>nil<code/> wird der Effekt global erzeugt.*/ object target, /* Priorität für den Effekt. Achtung: Die Priorität darf nicht 0 sein; ansonsten wird der Effekt nicht erzeugt!*/ int priority, /* Intervall, in dem Timer-Aufrufe getätigt werden. Bei <code>nil<code/> werden keine Timer-Aufrufe durchgeführt, und der Effekt bleibt permanent bis er durch anderwertige Aufrufe entfernt wird.*/ int timer, /* Befehlsziel. Wenn angegeben, werden alle Callbacks in diesem Objekt ausgeführt. Ansonsten finden diese Callbacks grundsätzlich ohne Objektkontext statt. Wenn das Befehlszielobjekt gelöscht wird, werden alle verbundenen Effekte ohne weitere Callbacks ebenfalls gelöscht. Falls das Befehlsziel seine Definition ändert, sollten verbundene Effekte mit <code>effect.Name = effect.Name<code/> ihre Funktionen neu zuweisen lassen.*/ object command_target, /* Definition, in der bei nicht angegebenem Befehlsziel-Objekt Callbacks ausgeführt werden. Sind sowohl command_target als auch command_target_id <code>nil<code/>, werden die Aufrufe global durchgeführt. Das heißt, die Fx*-Funktionen müssen als global deklariert sein, oder Enginefunktionen sein.*/ command_target_id, /* Erster Zusatzparameter, der an Fx*Start- und Fx*Effect-Callbacks übergeben wird*/ var1, /* Zweiter Zusatzparameter, der an Fx*Start- und Fx*Effect-Callbacks übergeben wird*/ var2, /* Dritter Zusatzparameter, der an Fx*Start- und Fx*Effect-Callbacks übergeben wird*/ var3, /* Vierter Zusatzparameter, der an Fx*Start- und Fx*Effect-Callbacks übergeben wird*/ var4);
//Fügt einen Menüeintrag hinzu.
global func int AddMenuItem(/* Text des neuen Menüeintrags*/ string caption, /* Kommando, das bei Auswahl des Menüeintrags ausgeführt werden soll. Kann entweder ein Funktionsname oder ein Statement sein. Wenn ein Funktionsname angegeben wird, dann wird die Funktion in dem Objekt aufgerufen, welches bei <funclink>CreateMenu<funclink/> als command_object übergeben wurde.*/ string command, /* Die ID wird als Bild für den Menüeintrag verwendet. Der Name der Definition kann mit %s in caption verwendet werden. Außerdem wird die ID als erster Parameter an den Aufruf von command übergeben, sofern dieser nur ein Funktionsname ist.*/ id symbol, /* Gewünschte Zahl, die neben dem Menüeintrag angezeigt werden soll (ähnlich der Mengenanzeige im Aktivieren-Menü)*/ int count, /* Wird als 2. Parameter an die in command angegebene Funktion übergeben (siehe Anmerkung)*/ parameter, /* Beschreibungstext des neuen Menüeintrags*/ string info_caption, /* Zusatzparameter für das Verhalten des Menüeintrags.<br><br/> Untere 7 Bits (0-127): Menüsymbol.<br><br/> 0: Normal<br><br/> 1: Rangsymbol. Bei angegebenem symbol wird ggf. die Rank.png der Definition genutzt. count gibt die Ranghöhe an<br><br/> 2: Picturefacet, das um XPar1-fache Picturebreite nach rechts verschoben ist. Damit lassen sich mehrere Menüsymbole innerhalb einer Definition unterbringen.<br><br/> 3: XPar1 gibt ein Objekt an, dessen Picture-Grafik mit Rang gezeichnet wird. Hat das Objekt keine Infosektion (und dmait keinen Rang), so wird in Kontextmenüs dennoch ein entsprechender Leerraum gelassen.<br><br/> 4: XPar1 gibt ein Objekt an, dessen Picture-Grafik gezeichnet wird.<br><br/> Bit 8 (128): XPar2 wird als Wertangabe benutzt, und überschreibt die Standardangabe (Wert der Definition symbol). Siehe auch extra von <funclink>CreateMenu<funclink/>*/ int extra, /* Erster Zusatzparameter für extra.*/ XPar1, /* Zweiter Zusatzparameter für extra.*/ XPar2);
//Erzeugt ein neues selbstdefiniertes Messageboard-Kommando. Dieses Kommando kann von jedem Spieler im Spiel durch Eingabe von "/[Kommandoname]" aufgerufen werden. In dem Fall wird der angegebene Script ausgeführt. Im Script kann "%s" dafür verwendet werden, eventuell angegebene Parameter einzubinden.
global func int AddMsgBoardCmd(/* Name des MessageBoard-Kommandos*/ string command, /* Auszuführender Script*/ string script);
//Fügt dem aufrufenden Objekt einen neuen Vertex hinzu.
global func int AddVertex(/* X-Koordinate, von der Objektmitte aus gesehen.*/ int x, /* Y-Koordinate, von der Objektmitte aus gesehen.*/ int y);
//Liefert den Winkel, in dem sich der zweite Punkt vom ersten Punkt aus gesehen befindet. Der Winkel wird in Grad zurückgeliefert, 0° ist senkrecht oben. Alle Koordinaten sind global.
global func int Angle(/* X-Koordinate des ersten Punktes*/ int x1, /* Y-Koordinate des ersten Punktes*/ int y1, /* X-Koordinate des zweiten Punktes*/ int x2, /* Y-Koordinate des zweiten Punktes*/ int y2, /* Gibt, wenn angegeben, den Winkel multipliziert mit precision zurück, um so genauere Winkel zu erhalten. Eine Präzision von 10 gibt also Werte zwischen 0 und 3600 zurück.*/ int precision);
//Der Wert hängt von der Bewegung des Objekts in X-Richtung ab. Jeder Pixel den sich das Objekt in X-Richtung bewegt erhöht den Wert etwas. Wenn end erreicht wurde wird der Wert wieder auf begin zurückgesetzt. Im Gegensatz zu <funclink>Anim_X<funclink/> bewegt sich der Wert immer auf end zu, egal in welche Richtung sich das Objekt bewegt.
global func array Anim_AbsX(/* Startwert. Sollte innerhalb des von begin und end aufgespannten Intervalls liegen.*/ int position, /* Beginn des Intervalls.*/ int begin, /* Schluss des Intervalls. Wenn end größer als begin ist, so nimmt der Wert mit der Bewegung des Objekts zu, andernfalls nimmt er ab.*/ int end, /* Anzahl Pixel die in X-Richtung zurückgelegt werden müssen um die Animation von begin bis nach end durchzuspielen.*/ int length);
//Der Wert hängt von der Bewegung des Objekts in Y-Richtung ab. Jeder Pixel den sich das Objekt in Y-Richtung bewegt erhöht den Wert etwas. Wenn end erreicht wurde wird der Wert wieder auf begin zurückgesetzt. Im Gegensatz zu <funclink>Anim_Y<funclink/> bewegt sich der Wert immer auf end zu, egal in welche Richtung sich das Objekt bewegt.
global func array Anim_AbsY(/* Startwert. Sollte innerhalb des von begin und end aufgespannten Intervalls liegen.*/ int position, /* Beginn des Intervalls.*/ int begin, /* Schluss des Intervalls. Wenn end größer als begin ist, so nimmt der Wert mit der Bewegung des Objekts zu, andernfalls nimmt er ab.*/ int end, /* Anzahl Pixel die in Y-Richtung zurückgelegt werden müssen um die Animation von begin bis nach end durchzuspielen.*/ int length);
//Der Wert hängt von der Phase der aktuellen Action ab. Die Phase wird linear auf die von der Action zur Zeit abgespielte Animation abgebildet (siehe <emlink>ActMap<emlink/>). Dies kann verwendet werden um Animationen synchron zur ActMap-Animation zu spielen.
global func array Anim_Action();
//Wertangabe für <funclink>PlayAnimation<funclink/>, <funclink>SetAnimationPosition<funclink/> oder <funclink>SetAnimationWeight<funclink/>: Über die komplette Zeitdauer der Animation wird der gegebene konstante Wert verwendet.
global func array Anim_Const(/* Zu verwendender Wert.*/ int value);
//Der Wert nimmt linear mit der Zeit (in Frames) zu oder ab (je nachdem ob end größer oder kleiner als begin ist). Anfangs beträgt der Wert position und läuft dann Richtung end. Ein Durchgang von begin bis nach end dauert length Frames. Wenn position von begin abweicht dann wird end bereits früher erreicht sein. on_ending bestimmt, was passiert, wenn das Ende erreicht ist.
global func array Anim_Linear(/* Startwert. Sollte innerhalb des von begin und end aufgespannten Intervalls liegen.*/ int position, /* Beginn des Intervalls.*/ int begin, /* Schluss des Intervalls. Wenn end größer als begin ist, so steigt der Wert mit der Zeit an, andernfalls nimmt er ab.*/ int end, /* Anzahl Frames die ein Durchspielen von begin bis end dauert.*/ int length, /* 
            Specifies what happens once end is reached. There are the following possibilities:
            <table>
              <rowh><col>Konstante<col/><col>Wert<col/><col>Beschreibung<col/><rowh/>
              <row><col>ANIM_Loop<col/><col>0<col/><col>Der Wert wird nach dem Erreichen von end wieder auf begin gesetzt und der Durchgang beginnt von neuem.<col/><row/>
              <row><col>ANIM_Hold<col/><col>1<col/><col>Nach Erreichen von end bleibt der Wert konstant auf end.<col/><row/>
              <row><col>ANIM_Remove<col/><col>2<col/><col>Nach Erreichen von end wird die zugehörige Animation entfernt wie wenn zum entsprechenden Zeitpunkt <funclink>AnimationStop<funclink/> aufgerufen würde. Bei Kombinationsknoten wird der Kindknoten mit der kleineren Gewichtung entfernt.<col/><row/>
            <table/>
          */ int on_ending);
//
global func array Anim_R(/* Beginn des Intervalls.*/ int begin, /* Schluss des Intervalls. Wenn end größer als begin ist, so nimmt der Wert mit der Bewegung des Objekts in positiver X-Richtung zu, andernfalls nimmt er ab.*/ int end);
//Der Wert hängt von der Bewegung des Objekts in X-Richtung ab. Jeder Pixel den sich das Objekt in positiver X-Richtung bewegt erhöht den Wert etwas, und jeder Pixel in negative X-Richtung verringert ihn etwas. Wenn end erreicht wurde wird der Wert wieder auf begin zurückgesetzt, und wenn begin erreicht wurde wird er auf end gesetzt.
global func array Anim_X(/* Startwert. Sollte innerhalb des von begin und end aufgespannten Intervalls liegen.*/ int position, /* Beginn des Intervalls.*/ int begin, /* Schluss des Intervalls. Wenn end größer als begin ist, so nimmt der Wert mit der Bewegung des Objekts in positiver X-Richtung zu, andernfalls nimmt er ab.*/ int end, /* Anzahl Pixel die in X-Richtung zurückgelegt werden müssen um die Animation von begin bis nach end durchzuspielen.*/ int length);
//Der Wert ist proportional zur X-Geschwindigkeit des Objekts. Die Geschwindigkeiten 0 bis max_dir werden linear auf den Wertebereich von begin bis end abgebildet.
global func array Anim_XDir(/* Beginn des Intervalls.*/ int begin, /* Schluss des Intervalls. Wenn end größer als begin ist, so nimmt der Wert mit größerer XDir zu, sonst nimmt er ab.*/ int end, /* Größter Wert der XDir der abgebildet soll. Noch größere Geschwindigkeiten führen zum gleichen Animationswert (end).*/ int max_dir);
//Der Wert hängt von der Bewegung des Objekts in Y-Richtung ab. Jeder Pixel den sich das Objekt in positiver Y-Richtung bewegt erhöht den Wert etwas, und jeder Pixel in negative Y-Richtung verringert ihn etwas. Wenn end erreicht wurde wird der Wert wieder auf begin zurückgesetzt, und wenn begin erreicht wurde wird er auf end gesetzt.
global func array Anim_Y(/* Startwert. Sollte innerhalb des von begin und end aufgespannten Intervalls liegen.*/ int position, /* Beginn des Intervalls.*/ int begin, /* Schluss des Intervalls. Wenn end größer als begin ist, so nimmt der Wert mit Bewegung des Objekts in positiver Y-Richtung zu, andernfalls nimmt er ab.*/ int end, /* Anzahl Pixel die in Y-Richtung zurückgelegt werden müssen um die Animation von begin bis nach end durchzuspielen.*/ int length);
//Der Wert ist proportional zur Y-Geschwindigkeit des Objekts. Die Geschwindigkeiten 0 bis max_dir werden linear auf den Wertebereich von begin bis end abgebildet.
global func array Anim_YDir(/* Beginn des Intervalls.*/ int begin, /* Schluss des Intervalls. Wenn end größer als begin ist, so nimmt der Wert mit größerer XDir zu, sonst nimmt er ab.*/ int end, /* Größter Wert der YDir der abgebildet soll. Noch größere Geschwindigkeiten führen zum gleichen Animationswert (end).*/ int max_dir);
//Fügt ein Kommando der Kommandoliste des aufrufenden Objekts am Ende hinzu. Das Objekt wird also das zuerst gegebene Kommando ausführen und sich danach automatisch dem mit AppendCommand hinzugefügten widmen.<br><br/> Für Kommando-Beschreibungen siehe <funclink>SetCommand<funclink/><br><br/> Bemerkung: Mit AppendCommand hinzugefügte Befehle werden nicht an gesteuerte Fahrzeuge weitergeleitet (siehe VehicleControl)
global func bool AppendCommand(/* Kommandoname (als String). Siehe untere Tabelle*/ string command, /* Zielobjekt für Aktion*/ object target, /* X-Zielkoordinate*/ int x, /* Y-Zielkoordinate*/ int y, /* zweites Zielobjekt*/ object target2, /* Zeit (in Ticks/Frames), bis das Kommando abgebrochen wird*/ int delay, /* zusätzliche Daten zur Aktion*/ Data, /* Anzahl der Wiederholungen (wenn das Kommando fehlschlägt), bis das Kommando abgebrochen wird.*/ int retries, /* Befehlsstapelmodus. Werte siehe <funclink>AddCommand<funclink/>.*/ int base_mode);
//Berechnet den Arcuscosinus von value/radius, also Result=arccos(value/radius). Dies entspricht cos(Result)=value/radius. Die Funktion wird benötigt, um Seitenverhältnisse zu einem Winkel umzurechnen. Für die meisten Fälle ist <funclink>Angle<funclink/>() aber ausreichend und praktischer.
global func int ArcCos(/* Länge der Ankathete*/ int value, /* Länge der Hypotenuse*/ int radius);
//Berechnet den Arcussinus von value/radius, also Result=arcsin(value/radius). Dies entspricht Sin(Result)=value/radius. Die Funktion wird benötigt, um Seitenverhältnisse zu einem Winkel umzurechnen. Für die meisten Fälle ist <funclink>Angle<funclink/>() aber ausreichend und praktischer.
global func int ArcSin(/* Länge der Gegenkathete*/ int value, /* Länge der Hypotenuse*/ int radius);
//Befestigt ein Mesh an einem anderen. Wenn für <code>mesh<code/> eine ID angegeben wird, so wird das Mesh der entsprechenden Definition verwendet. Wenn für <code>mesh<code/> ein Objekt angegeben wird, so wird dessen aktuelles Mesh verwendet, inklusive aller Animationen oder weiterer angehängter Meshes. Dabei wird jedoch nur die Grafik angehangen, das Objekt selbst bleibt weiter an seiner gegenwärtigen Position. Der Rückgabewert ist eine Nummer mit Hilfe derer das Mesh mit <funclink>DetachMesh<funclink/> wieder gelöst werden kann.
global func int AttachMesh(/* ID oder Objekt des Meshes das angehängt werden soll.*/ mesh, /* Bone am Mesh des aufrufenden Objekts an dem das anzuhängende Mesh befestigt werden soll.*/ string parent_bone, /* Bone am Mesh des anzuhängenden Objekts mit dem es befestigt werden soll.*/ string child_bone, /* Transformation im Koordinatensystem des anzuhängenden Meshes, die auf selbiges angewandt wird. Das Array sollte 12 Integer-Einträge haben die eine 3x4-Matrix beschreiben wobei jeder Wert in Promille (1000 = 100%) angegeben ist. Die Matrizen können auch mit <funclink>Trans_Identity<funclink/>, <funclink>Trans_Translate<funclink/>, <funclink>Trans_Rotate<funclink/> und <funclink>Trans_Scale<funclink/> erzeugt und mit <funclink>Trans_Mul<funclink/> kombiniert werden.*/ array transformation, /* 
            Additional flags to specify the behavior of the attached mesh. Multiple values can be separated with <code>|<code/>. The following values are allowed:
            <table>
              <rowh>
                <col>Wert<col/>
                <col>Beschreibung<col/>
              <rowh/>
              <row>
                <literal_col>AM_DrawBefore<literal_col/>
                <col>Normalerweise wird das Mesh des Objekts selbst vor dem des angehängten Meshes gezeichnet. Wenn dieses Flag angegeben wird so wird jedoch das angehängte Mesh zuerst gezeichnet. Im Normalfall macht das keinen Unterschied da durch einen Z-Puffer sichergestellt wird, dass die Darstellung richtig ist. Wenn allerdings eines oder beide der Meshes Alpha Blending benutzen dann wird die Zeichenreihenfolge relevant da es sonst vorkommen kann dass ein Mesh hinter einem (teilweise) durchsichtigen Teil des anderen Meshes unsichtbar wird.<col/>
              <row/>
            <table/>
          */ int flags);
//Fügt allen Objekten an angegebener Position Explosionsschaden zu. x und y sind immer globale Koordinaten. Wenn ein container angegeben ist, wird der Schaden nur den Objekten zugefügt, die in container enthalten sind. Explosionsschaden kann zur Entzündung führen oder auch Lebewesen wegschleudern.
global func int BlastObjects(/* X-Koordinate*/ int x, /* Y-Koordinate*/ int y, /* Stärke*/ int level, /* Objekt, in dem die zu sprengenden Objekte enthalten sind.*/ object container, /* Spielernummer des Spielers, der der Verursacher des Schaden ist. Wenn nicht angegeben, gilt bei lokalen Aufrufen der Schaden als vom Controller des aufrufenden Objekts verursacht.*/ int caused_by);
//Gibt value zurück, wenn der Wert innerhalb der Grenzen liegt (value >= lower_bound und value <= upper_bound). Andernfalls wird die jeweils nächstliegende Grenze zurückgegeben.
global func int BoundBy(/* Zu vergleichende Zahl*/ int value, /* Untere Grenze*/ int lower_bound, /* Obere Grenze*/ int upper_bound);
//Erzeugt eine Luftblase.
global func bool Bubble(/* X-Position der Luftblase. Offset bei lokalem Aufruf.*/ int x, /* Y-Position der Luftblase. Offset bei lokalem Aufruf.*/ int y);
//Kauft ein Objekt für for_player, und zieht pay_player Geld ab. Wenn dieser nicht genug Geld oder das Objekt nicht im Heimatbasismaterial hat, wird der Vorgang nicht ausgeführt.
global func object Buy(/* ID des Objekttyps, der gekauft wird*/ id buy_object, /* Nummer des Spielers, dem das Objekt hinterher gehört*/ int for_player, /* Nummer des Spielers, der den Kauf bezahlt*/ int pay_player, /* Zielobjekt, in das das neu gekaufte Objekt hineinversetzt wird. Dieser Parameter kann ausgelassen werden wenn das aufrufende Objekt eine Basis ist.*/ object to_base, /* Wenn angegeben und ungleich <code>false<code/>, werden Fehlermeldugnen wie "Kaufen nicht möglich" aufgrund von Geldmangel angezeigt.*/ bool show_errors);
//Wandelt einen String in eine ID um.
global func id C4Id(/* Der String, der in eine id umgewandelt werden soll.*/ string id_string);
//Calls the specified function. If given a string, the function is looked up in the context object (<code>this<code/>). For example, <code>obj->Call("Foo")<code/> is the same as <code>obj->Foo()<code/>. Using Call like this is primarily useful when the name of the function can vary. If "~" is prepended to the function name then the call does not fail if the function does not exist.
global func any Call(/* Funktion, die aufgerufen werden soll.*/ function);
//Tested ob die Bilder zweier Objekte gleich sind und sie somit in Inhaltsanzeigen gestapelt werden können.
global func bool CanConcatPictureWith(/* Das Object mit dem verglichen werden soll.*/ object other);
//Verschleudert number Objekte an angegebener Position mit einer Geschwindigkeit von level. Bei einem lokalen Aufruf haben die erzeugten Objekte den selben Besitzer wie das aufrufende Objekt.
global func int CastObjects(/* ID des Objekttyps, der verschleudert wird*/ id, /* Anzahl verschleuderter Objekte.*/ number, /* Geschwindigkeit der verschleuderten Objekte*/ level, /* X-Ausgangsposition. Offset zum aufrufenden Objekt bei lokalem Aufruf.*/ x, /* Y-Ausgangsposition. Offset zum aufrufenden Objekt bei lokalem Aufruf.*/ y, /* Winkel in den die Objekte verschleudert werden.*/ angle, /* Maximale Abweichung von diesem Winkel. Wenn nicht angegeben werden Objekte in alle Richtungen verschleudert.*/ angle_variance);
//Verschleudert amount Partikel vom angegebenen Typ. Die Zusatzparameter werden zufällig zwischen a0/b0 und a1/b1 gesetzt.
global func bool CastParticles(/* Name des Partikeltyps*/ string name, /* Anzahl der Partikel*/ int amount, /* Geschwindigkeit, mit der verschleudert werden soll*/ int level, /* X-Position des Partikels. Relative Koordinaten bei lokalem Aufruf.*/ int x, /* Y-Position des Partikels. Relative Koordinaten bei lokalem Aufruf.*/ int y, /* Untere Schranke für den ersten Zusatzparameter. Dies ist normalerweise die Größe des Partikels in 1/5-Pixeln.*/ int a0, /* Obere Schranke für den ersten Zusatzparameter*/ int a1, /* Untere Schranke für den zweiten Zusatzparameter. Dies ist normalerweise die Farbmodulation des Partikels.*/ int b0, /* Obere Schranke für den zweiten Zusatzparameter*/ int b1, /* Zielobjekt für objektlokale Partikel. Objektlokale Partikel werden direkt über den jeweiligen Objekten gezeichnet, und beim Entfernen des Objekts gelöscht.*/ object obj);
//Verschleudert namentlich angegebene Materialpixel an angegebener Position. Bei einem lokalen Aufruf gelten die Koordinaten als Offset zum aufrufenden Objekt.
global func int CastPXS(/* Materialname*/ string material_name, /* Menge*/ int amount, /* Stärke*/ int level, /* X-Koordinate*/ int x, /* Y-Koordinate*/ int y, /* Winkel in den die Materialpixel verschleudert werden.*/ angle, /* Maximale Abweichung von diesem Winkel. Wenn nicht angegeben werden Materialpixel in alle Richtungen verschleudert.*/ angle_variance);
//Weist einem Objekt eine neue Definition zu.
global func bool ChangeDef(/* ID der neuen Definition für das Objekt*/ id new_def);
//
global func bool CheckConstructionSite(/* Typ des zu prüfenden Objekts*/ id object_id, /* X-Koordinate*/ int xoffset, /* Y-Koordinate*/ int yoffset);
//Führt Fx*Effect (und ggf. auch Fx*Add)-Callbacks in der entsprechenden Effektliste aus, ohne einen Effekt selber zu erstellen. Rückgabewert ist -1, wenn ein anderer Effekt den Effekt abgelehnt hat, und die Effektnummer des aufnehmenden Effektes, wenn der Effekt aufgenommen wurde.
global func int CheckEffect(/* Name des Effektes ohne vorangestelltes Fx.*/ string name, /* Zielobjekt, dessen Effekte benachrichtigt werden. Bei <code>nil<code/> wird die globale Effektliste benachrichtigt.*/ object target, /* Priorität für den Effekt. Es werden Fx*Effect-Callbacks bei allen Effekten mit gleicher und höherer Priorität durchgeführt. Wenn nicht angegeben oder bei 0 werden daher alle Effekte benachrichtigt.*/ int priority, /* Intervall, in dem Timer-Aufrufe getätigt werden. Bei <code>nil<code/> werden keine Timer-Aufrufe durchgeführt, und der Effekt bleibt permanent bis er durch anderwertige Aufrufe entfernt wird.*/ int timer, /* Erster Zusatzparameter, der an Effect-Callbacks übergeben wird*/ var1, /* Zweiter Zusatzparameter, der an Fx*Effect-Callbacks übergeben wird*/ var2, /* Dritter Zusatzparameter, der an Fx*Effect-Callbacks übergeben wird*/ var3, /* Vierter Zusatzparameter, der an Fx*Effect-Callbacks übergeben wird*/ var4);
//Prüft ob dieses Objekt für den angegebenen Spieler sichtbar ist.
global func bool CheckVisibility(/* Spieler für den die Sichtbarkeit abgefragt wird.*/ int player);
//Entfernt alle Einträge aus einem Menü.
global func int ClearMenuItems();
//Entfernt alle Partikel eines angegebenen Typs.
global func bool ClearParticles(/* Name der Partikeldefinition, dessen Instanzen gelöscht werden sollen. Wenn nicht angegeben werden alle Partikel entfernt.*/ string name, /* Wenn angegeben, werden nur Partikel entfernt die lokal zum Objekt sind.*/ object obj);
//Bricht durch <funclink>ScheduleCall<funclink/> erzeugte verzögerte Funktionsaufrufe ab. Alle momentan wartenden Funktionsaufrufe an die angegebene Funktion und das angegebene Objekt werden abgebrochen.
global func bool ClearScheduleCall(/* Objekt, für das verzögerte Funktionsaufrufe abgebrochen werden sollen. <code>nil<code/> für verzögerte Funktionsaufrufe ohne Objektkontext*/ object obj, /* Name der Funktion, die durch die abzubrechenden Aufrufe aufgerufen würde.*/ string function);
//Schließt das Menü des aufrufenden Objekts.
global func bool CloseMenu();
//Sammelt ein Objekt auf. Der Befehl führt dieselben Funktionen aus, als wäre das Objekt durch den normalen Collection-Bereich des Objekts eingesammelt worden (z.B. RejectCollect, Prüfung auf Flagge/Flagge abnehmbar, Hit-Aufruf bei OCF_HitSpeed2, usw.). Die einzigen Unterschiede sind, dass keine Prüfung der Position von item auf den Entrance-Bereich von target/this() gemacht wird, und dass item nicht auf OCF_Carryable geprüft wird.<br><br/>Mit diesem Befehl lässt sich beispielsweise das Aufnehmen von Objekten aus Containern heraus realisieren. Wenn die Aufnahme fehlschlug (Beispielsweise durch den RejectCollect-Aufruf oder weil der Container voll war), gibt die Funktion <code>false<code/> zurück. Ansonsten <code>true<code/>.
global func bool Collect(/* Objekt, das aufgesammelt werden soll*/ object item);
//Prüft, ob das aufrufende Objekt nur aus Objekten vom Typ id besteht.
global func bool ComponentAll(/* ID der erwarteten Components.*/ id components);
//Erzeugt ein Objekt vom Typ id als Inhalt des aufrufenden Objekts. Das Objekt wird aus seinen Komponenten zusammen gesetzt, die im aufrufenden Objekt enthalten sein müssen. Andernfalls wird eine Meldung ausgegeben, welche Objekte noch benötigt werden. Auch ComposeContents produziert den Engine Objekt-Call BuildNeedsMaterial, durch den die Meldung über noch benötigtes Material ausgewertet und abgefangen werden kann.
global func object ComposeContents(/* Typ des zu erstellenden Objekts*/ id object_id);
//Wird bei der Erzeugung eines Objekts aufgerufen.
global func any Construction(/* Objekt welches das neu erstellte Objekt erzeugt hat. <code>nil<code/> wenn es global (Szenarioscript,...) erstellt wurde.*/ object creator);
//Liefert das Objekt, in dem sich das aufrufende Objekt befindet, oder <code>nil<code/>, wenn es in keinem anderen Objekt enthalten ist.
global func object Contained();
//Liefert das indizierte Objekt, das im aufrufenden Objekt enthalten ist.
global func object Contents(/* Index des Objekts in obj, Zählung beginnt mit 0*/ int index);
//Liefert die Anzahl der Objekte vom Typ id, die im aufrufenden Objekt enthalten sind.
global func int ContentsCount(/* Objekttyp, der gezählt wird*/ id object_id);
//Liefert cos(angle) * radius.
global func int Cos(/* Winkel in Grad*/ int angle, /* Radius*/ int radius, /* Der angegebene Winkel wird, wenn angegeben, vor der Berechnung durch diesen Wert dividiert. Bei einem Winkel von 455 und einer Präzision von 10 würde intern also mit einem Winkel von 45,5° gerechnet werden.*/ int precision);
//Erzeugt ein neues, mit Nullen gefülltes Feld.
global func array CreateArray(/* Länge des neuen Felds*/ int length);
//Sollte statt <funclink>CreateObject<funclink/> benutzt werden, wenn ein Gebäude oder eine Baustelle erzeugt werden soll. Bei lokalen Aufrufen dieser Funktion wird die angegebene Position zu Offset-Koordinaten zum aufrufenden Objekt. Wenn check_site 1 ist, wird die Baustelle vorher auf ihre Eignung überprüft. Ist die Position ungeeignet (z.B. durch unebenen Untergrund oder andere Gebäude), wird beim aufrufenden Objekt eine entsprechende Meldung ausgegeben und die Funktion gibt <code>nil<code/> zurück.
global func object CreateConstruction(/* Typ des zu erstellenden Objekts*/ id object_id, /* X-Koordinate*/ int xoffset, /* Y-Koordinate*/ int yoffset, /* Besitzer des neuen Objektes (valide Spielernummer oder <funclink>NO_OWNER<funclink/> für kein Besitzer)*/ int owner, /* Gibt die Fertigstellung des Objekts in Prozent an (muss mindestens 1 sein)*/ int completion, /* Bestimmt, ob die Landschaft an die Baustelle angepasst werden soll (inkl. Fundament).*/ bool adjust_terrain, /* Überprüft die Baustelle vorher auf ihre Eignung*/ bool check_site);
//Erzeugt ein Objekt vom Typ id als Inhalt des aufrufenden Objekts.
global func object CreateContents(/* Typ des zu erstellenden Objekts*/ id id, /* Anzahl zu erstellender Objekte. Wenn nicht angegeben, wird 1 angenommen.*/ int count);
//Erzeugt ein benutzerdefiniertes Menü im aufrufenden Objekt. Menüeinträge müssen mit <funclink>AddMenuItem<funclink/> hinzugefügt werden.
global func bool CreateMenu(/* Objektdefinition, deren Bild als Symbol verwendet wird*/ id symbol, /* Erhält das Menükommando (siehe <funclink>AddMenuItem<funclink/>); kann bei lokalen Aufrufen <code>nil<code/> sein.*/ object command_object, /* 
            Additional information to be displayed about the currently selected entry. C4MN_ values are now also defined as constants: 
            <table>
              <rowh>
                <col>Konstante<col/>
                <col>Wert<col/>
                <col>Effekt<col/>
              <rowh/>
              <row>
                <col>C4MN_Extra_None<col/>
                <col>0<col/>
                <col>Nichts<col/>
              <row/>
              <row>
                <col>C4MN_Extra_Components<col/>
                <col>1<col/>
                <col>Komponenten<col/>
              <row/>
              <row>
                <col>C4MN_Extra_Value<col/>
                <col>2<col/>
                <col>Wert<col/>
              <row/>
              <row>
                <col>C4MN_Extra_MagicValue<col/>
                <col>3<col/>
                <col>Wert als Magiewert. Dabei wird außerdem extra_data als Vergleichswert angezeigt, z.B. "50/100".<col/>
              <row/>
              <row>
                <col>C4MN_Extra_Info<col/>
                <col>4<col/>
                <col>Beschreibungstext sofort anzeigen<col/>
              <row/>
              <row>
                <col>C4MN_Extra_ComponentsMagic<col/>
                <col>5<col/>
                <col>Komponenten und Magiewert<col/>
                <col><col/>
              <row/>
            <table/>

          */ int extra, /* Bestimmt den angezeigten Menütext, wenn das Menü keine Einträge enthält*/ string caption, /* Vergleichswert für extra 3*/ int extra_data, /* 
            Appearance of the menu. The following constants are defined: 
            <table>
              <rowh>
                <col>Konstante<col/>
                <col>Wert<col/>
                <col>Aussehen<col/>
              <rowh/>
              <row>
                <col>C4MN_Style_Normal<col/>
                <col>0<col/>
                <col>Normal<col/>
              <row/>
              <row>
                <col>C4MN_Style_Context<col/>
                <col>1<col/>
                <col>Kontextmenü<col/>
              <row/>
              <row>
                <col>C4MN_Style_Info<col/>
                <col>2<col/>
                <col>Infomenü<col/>
              <row/>
              <row>
                <col>C4MN_Style_Dialog<col/>
                <col>3<col/>
                <col>Dialog<col/>
              <row/>
              <row>
                <col>C4MN_Style_EqualItemHeight<col/>
                <col>128<col/>
                <col>Kann mit C4MN_Style_Dialog kombiniert werden: Alle Einträge mit Icon im Dialogmenü bekommen die gleiche Höhe.<col/>
              <row/>
            <table/>

          */ int style, /* Das Menü bleibt geöffnet, wenn eine Auswahl getroffen wird.*/ bool permanent, /* Wenn angegeben, wird diese ID als Menü-ID gesetzt. Die aktuelle Menü-ID wird zum Beispiel von <funclink>GetMenu<funclink/> zurückgegeben.*/ id menu_id);
//Erzeugt ein Objekt des angegebenen Typs an der angegebenen Position. xoffset und yoffset bestimmen die Position in absoluten Pixel-Koordinaten der Landschaft (Mitte Unterkante des Objekts). Bei lokalen Aufrufen dieser Funktion wird die angegebene Position zu Offset-Koordinaten zum aufrufenden Objekt.
global func object CreateObject(/* Typ des zu erstellenden Objekts*/ id id, /* X-Koordinate*/ int xoffset, /* Y-Koordinate*/ int yoffset, /* Besitzer des zu erstellenden Objekts. Entweder der Index eines Spielers oder <code><funclink>NO_OWNER<funclink/><code/> für keinen Besitzer. Wenn nicht angegeben wird der Besitzer des neuen Objektes auf den Controller des aufrufenden Objektes gesetzt bzw. <code>NO_OWNER<code/> wenn CreateObject ohne Objektkontext aufgerufen wird.*/ int owner);
//Erzeugt ein Partikel. Das Partikel muss unter dem angegebenen Namen geladen sein. Für weitere Informationen siehe Partikeldokumentation.
global func bool CreateParticle(/* Name des Partikels*/ string szName, /* X-Position des Partikels. Relative Koordinaten bei lokalem Aufruf.*/ int x, /* Y-Position des Partikels. Relative Koordinaten bei lokalem Aufruf.*/ int y, /* Horizontale Anfangsgeschwindigkeit des Partikels*/ int xdir, /* Vertikale Anfangsgeschwindigkeit des Partikels*/ int ydir, /* Zusatzparameter. Dies ist normalerweise die Größe des Partikels in 1/5-Pixeln.*/ int a, /* Zweiter Zusatzparameter. Dies ist normalerweise die Farbmodulation des Partikels.*/ int b, /* Zielobjekt für objektlokale Partikel. Objektlokale Partikel werden direkt über den jeweiligen Objekten gezeichnet, und beim Entfernen des Objekts gelöscht.*/ object target, /* Wenn angegeben und nicht <code>false<code/>, wird der Partikel hinter dem Zielobjekt gezeichnet.*/ bool behind_target);
//Erzeugt ein Partikel. Das Partikel muss unter dem angegebenen Namen geladen sein. Für weitere Informationen siehe Partikeldokumentation.
global func bool CreateParticleAtBone(/* Name des Partikels*/ string szName, /* Geschwindigkeit, mit der verschleudert werden soll*/ string szBoneName, /* */ array pos, /* */ array dir, /* Zusatzparameter. Dies ist normalerweise die Größe des Partikels in 1/5-Pixeln.*/ int a, /* Zweiter Zusatzparameter. Dies ist normalerweise die Farbmodulation des Partikels.*/ int b, /* Zielobjekt für objektlokale Partikel. Objektlokale Partikel werden direkt über den jeweiligen Objekten gezeichnet, und beim Entfernen des Objekts gelöscht.*/ object target, /* Wenn angegeben und nicht <code>false<code/>, wird der Partikel hinter dem Zielobjekt gezeichnet.*/ bool behind_target);
//Initiiert den Beitritt eines Scriptspielers. Scriptspieler berhalten sich von der Scriptseite wie reguläre Spieler. Sie haben eine Stammcrew, ein Konto, Baupläne, Heimatbasismaterial, Verfeindungen, Teams, etc. Für diese Spieler wird jedoch regulär kein Sichtfenster geöffnet und sie lassen sich nicht von menschlichen Spielern steuern.<br><br/>Scriptspieler können zum Beispiel verwendet werden, um KI-Gegner wie z.B. Bots in Hazard zu realisieren.
global func bool CreateScriptPlayer(/* Name für den Scriptspieler. Muss angegeben werden.*/ string name, /* Spielerfarbe*/ int color, /* Team-ID. Wird 0 angegeben, so wird ein Team nach denselben Regeln ausgewählt wie bei einem normal beitretenden Spieler.*/ int team, /* 
            Bit mask composed of the following values: 
            <table>
              <rowh>
                <col>Bit<col/>
                <col>Konstante<col/>
                <col>Beschreibung<col/>
              <rowh/>
              <row>
                <col>0<col/>
                <col>CSPF_FixedAttributes<col/>
                <col>Wenn gesetzt, tritt der Spieler garantiert mit den in den Parameter angegebenen Namen und Farbe bei. Ansonsten werden die Attribute bei Kollisionen geändert.<col/>
              <row/>
              <row>
                <col>1<col/>
                <col>CSPF_NoScenarioInit<col/>
                <col>Wenn wahr, wird die Szenarieninitialisierung, also das Erzeugen von Heimatbasismaterial und Clonks, das Setzen der Baupläne nach Szenarienvorgaben, etc., nicht durchgeführt. Außerdem werden die globalen PreInitializePlayer- und InitializePlayer-Callbacks ans Szenarienscript und die Spielziel-, Regel- und Umweltobjekte nicht ausgeführt. Stattdessen wird ein InitializeScriptPlayer(Spielernummer, Team)-Callback als DefinitionCall (d.h. ohne <placeholder-1><placeholder-1/>-Objekt) auf der in extra_data angegebenen Definition ausgeführt. Mit diesem Parameter lassen sich also spezialisierte Scriptspieler realisieren, die nicht gleichberechtigt mit menschlichen Spielern agieren.<col/>
              <row/>
              <row>
                <col>2<col/>
                <col>CSPF_NoEliminationCheck<col/>
                <col>Wenn gesetzt, wird der Spieler nicht automatisch eliminiert, wenn er keine Crew mehr hat.<col/>
              <row/>
              <row>
                <col>3<col/>
                <col>CSPF_Invisible<col/>
                <col>Wenn gesetzt, ist der Spieler nicht in Spielerlisten wie zum Beispiel in der Lobby und im Verfeindungsmenü sichtbar.<col/>
              <row/>
            <table/>

          */ int flags, /* ID, die durchgereicht und an den InitializePlayer-Aufruf weitergegeben wird. Durch Angabe einer ID lassen sich Scriptspieler-Typen unterscheiden. Beispielsweise könnte ein Szenario dynamisch Alien- oder Clonkgegner anbieten.*/ id extra_data);
//Gibt eine Nachricht aus.
global func bool CustomMessage(/* Nachricht, die ausgegeben wird*/ string message, /* Wenn ungleich <code>nil<code/>, wird die Nachricht über dem angegebenen Objekt ausgegeben.*/ object obj, /* Nummer des Spielers, bei dem die Nachricht ausgegeben wird. Default ist <code>NO_OWNER<code/>, welches die Nachricht für alle Spieler anzeigt.*/ int plr, /* x-Offset der Nachrichtenposition. Bei globalen Nachrichten ist dies die Viewportmitte. Bei Objektnachrichten ist dies relativ zur Standard-Nachrichtenposition über dem Objekt. Bei Portrait-Nachrichten (portrait!=0) ist das Offset relativ zur oberen, linken Viewportecke.*/ int offset_x, /* y-Offset der Nachrichtenposition.*/ int offset_y, /* Farbe der Nachricht. Default ist 0xffffff (weiß).*/ int color, /* ID der Objektdefinition, die für Dekoration der Nachricht verwendet wird. Wenn angegeben, wird die Nachricht von einem Rahmen umgeben. Nur gültig bei angegebenem Portrait.*/ id deco, /* Definition oder Objekt dessen Grafik als Portrait benutzt werden soll.*/ portrait, /* 
            Bit mask specifying additional options. Possible values: 
            <table>
              <rowh>
                <col>Bit<col/>
                <col>Konstante<col/>
                <col>Beschreibung<col/>
              <rowh/>
              <row>
                <col>0<col/>
                <col>MSG_NoBreak<col/>
                <col>Wenn gesetzt, werden keine automatischen Zeilenumbruch bei langen Nachrichten eingefügt.<col/>
              <row/>
              <row>
                <col>1<col/>
                <col>MSG_Bottom<col/>
                <col>Nur globale Nachrichten. Für Portraitnachrichten mit Dekorationsrahmen: Das Nachrichtenoffset gibt die Verschiebung zur unteren Bildschirmkante anstatt zur oberen Bildschirmkante an. Für nicht-Portraitnachrichten setzt das Flag die Nachricht etwas tiefer.<col/>
              <row/>
              <row>
                <col>2<col/>
                <col>MSG_Multiple<col/>
                <col>Wenn gesetzt, werden vorherige Nachrichten des gleichen Typs nicht gelöscht.<col/>
              <row/>
            <table/>

          */ int flags);
//Gibt eine Botschaft a la "[name] ist von uns gegangen" über dem aufrufenden Objekt aus.
global func any DeathAnnounce();
//Wird nach dem Laden der Definitionen aufgerufen. Sollte nur die aktuelle Definiton Ã¤ndern.
global func any Definition(/* Definition, die initialisiert wird.*/ proplist def);
//Wurde zuvor mit <funclink>AttachMesh<funclink/> ein Mesh an einem anderen befestigt, so kann es mit dieser Funktion wieder gelöst werden.
global func bool DetachMesh(/* Nummer des zu entfernenden angehängten Meshes. Der Rückgabewert von <funclink>AttachMesh<funclink/> bildet solch eine Nummer.*/ int attach_number);
//
global func int DigFree(/* X-Koordinate*/ int x, /* Y-Koordinate*/ int y, /* Radius*/ int radius, /* */ bool no_dig2objects);
//
global func int DigFreeRect(/* X-Koordinate*/ int x, /* Y-Koordinate*/ int y, /* Breite*/ int width, /* Höhe*/ int height, /* */ bool no_dig2objects);
//Berechnet den Abstand zwischen zwei Punkten. Die Funktion entspricht Sqrt((x2-x1)^2 + (y2-y1)^2;).
global func int Distance(/* X-Position des ersten Punktes*/ int x1, /* Y-Position des ersten Punktes*/ int y1, /* X-Position des zweiten Punktes*/ int x2, /* Y-Position des zweiten Punktes*/ int y2);
//Verändert den Atemwert eines Objekts.
global func bool DoBreath(/* Verändert den Atemwert eines Objekts in Frames.*/ int change);
//Verändert die Fertigstellung des aufrufenden Objekts. Die meisten Lebewesen und Bäume können dadurch vergrößert oder verkleinert werden. Gebäude können zu Baustellen zurückgesetzt und Baustellen vorwärts oder rückwärts gebaut werden.<br><br/> Sinkt die Fertigstellung eines Objekts auf oder unter 0, wird dieses gelöscht.
global func any DoCon(/* Veränderung der Fertigstellung in Prozentpunkten; positiv oder negativ.*/ int change);
//Gibt dem aufrufenden Clonk Erfahrungspunkte.
global func any DoCrewExp(/* Veränderung des Erfahrungswertes*/ int change);
//Verändert den Schadenswert des aufrufenden Objekts. Bei change ungleich Null wird im Zielobjekt außerdem die Funktion Damage aufgerufen.
global func any DoDamage(/* Veränderung des Schadenswertes; positiv oder negativ*/ int change, /* Schadensursache, die an Fx*Damage-Callbacks von Effekten übergeben wird (siehe <emlink>Effekte-Dokumentation<emlink/>). Standard ist FX_Call_DmgScript.*/ int damage_type, /* Spielernummer des Spielers, der den Schaden verursacht hat.*/ int caused_by);
//Verändert die Energie des aufrufenden Objekts. Die Energie entspricht bei Lebewesen der Lebensenergie.
global func any DoEnergy(/* Veränderung des Energiewertes; positiv oder negativ in Prozent zum Maximalwert. 100% entsprechen hierbei dem maximalen Physical-Wert von 100000.*/ int change, /* Wenn <code>true<code/>, wird change auf den exakten Energiewert angewendet (0 bis Wert von Physical "Energy").*/ bool exact, /* Schadensursache, die an Fx*Damage-Callbacks von Effekten übergeben wird (siehe <emlink>Effekte-Dokumentation<emlink/>). Standard ist FX_Call_EngScript.*/ int damage_type, /* Spielernummer des Spielers, der den Schaden verursacht hat.*/ int caused_by);
//Verändert die Kaufbarkeit von Objekten in der Heimatbasis.
global func bool DoHomebaseMaterial(/* Spielernummer des Spielers, dessen Heimatbasismaterial verändert werden soll*/ int player, /* ID des Objekttyps, der mehr oder weniger oft kaufbar sein soll*/ id definition, /* Positive oder negative Veränderung der kaufbaren Objektmenge*/ int change);
//Verändert die Nachlieferung von kaufbaren Objekten in der Heimatbasis.
global func bool DoHomebaseProduction(/* Spielernummer des Spielers, dessen Heimatbasismaterial-Nachlieferung verändert werden soll*/ int player, /* ID des Objekttyps, der schneller oder langsamer nachgeliefert werden soll.*/ id type, /* Positive oder negative Veränderung der nachgelieferten Objektmenge*/ int change);
//Verändert den Punktewert eines Spielers.
global func bool DoPlayerScore(/* Spielernummer des Spielers, dessen Punktewert verändert werden soll*/ int player, /* Positiv oder negativ: Die Veränderung des Punktewertes*/ int change);
/*

      Adds a specified color value to a 32 bit color value. 
      <table>
        <rowh>
          <literal_col>select<literal_col/>
          <col>Auswahl<col/>
        <rowh/>
        <row>
          <literal_col>0<literal_col/>
          <col>Alpha-Wert<col/>
        <row/>
        <row>
          <literal_col>1<literal_col/>
          <col>Rotanteil<col/>
        <row/>
        <row>
          <literal_col>2<literal_col/>
          <col>Grünanteil<col/>
        <row/>
        <row>
          <literal_col>3<literal_col/>
          <col>Blauanteil<col/>
        <row/>
      <table/>

    
*/
global func int DoRGBaValue(/* 32Bit-Farbwert*/ int Val, /* Farbwert, der dazuaddiert werden soll.*/ int change, /* 0-3: Farbwert, der geändert werden soll*/ int select);
//Ändert den Sichtbarkeitszähler für das Scoreboard. Der intern verwaltete Zähler beginnt bei 0. Ist er größer als 0, wird das Scoreboard gezeigt. Ist er kleiner als 0, wird es verborgen. Ist er gleich 0, wird das Scoreboard nur dann gezeigt, wenn der Spieler die entsprechende Taste (normalweise Tab) drückt.
global func bool DoScoreboardShow(/* Änderung der Sichtbarkeit des Scoreboards.*/ int change, /* Wenn größer 0, Spielernummer+1 des Spielers, für den die Scoreboard-Sichtbarkeit geändert werden soll.*/ int for_player);
//Verändert das Vermögen eines Spielers.
global func bool DoWealth(/* Spielernummer des Spielers, dessen Vermögen verändert werden soll*/ int player, /* Die Änderung des Vermögens.*/ int value);
//Zeichnet eine dynamische Zufallskarte über einen Bereich der alten Landschaft. Dazu wird die angegebene Karte in der Landscape.txt gesucht.
global func bool DrawDefMap(/* Linke Kante des Rechtecks, in dem die Karte gezeichnet werden soll*/ int x, /* Obere Kante des Rechtecks, in dem die Karte gezeichnet werden soll*/ int y, /* Breite des Rechtecks, in dem die Karte gezeichnet werden soll*/ int width, /* Höhe des Rechtecks, in dem die Karte gezeichnet werden soll*/ int height, /* Name der zu benutzenden Karte aus der Landscape.txt*/ string map_name);
//Zeichnet eine dynamische Zufallskarte über einen Bereich der alten Landschaft. Dazu wird derselbe Generator benutzt, der auch die Karten der Landscape.txt zeichnet.
global func bool DrawMap(/* Linke Kante des Rechtecks, in dem die Karte gezeichnet werden soll*/ int x, /* Obere Kante des Rechtecks, in dem die Karte gezeichnet werden soll*/ int y, /* Breite des Rechtecks, in dem die Karte gezeichnet werden soll*/ int width, /* Höhe des Rechtecks, in dem die Karte gezeichnet werden soll*/ int height, /* Definition der dynamischen Karte. Das umschließende map { ...} - Tag muss vorhanden sein.*/ string map);
//Zeichnet ein viereckiges Polygon im angegebenen Material mit der angegebenen Textur.
global func bool DrawMaterialQuad(/* Material-Textur-Tupel für das Material, das gezeichnet werden soll*/ string szMaterialTexture, /* X-Position des ersten Eckpunktes. Immer global.*/ int x1, /* Y-Position des ersten Eckpunktes. Immer global.*/ int y1, /* X-Position des zweiten Eckpunktes. Immer global.*/ int x2, /* Y-Position des zweiten Eckpunktes. Immer global.*/ int y2, /* X-Position des dritten Eckpunktes. Immer global.*/ int x3, /* Y-Position des dritten Eckpunktes. Immer global.*/ int y3, /* X-Position des vierten Eckpunktes. Immer global.*/ int x4, /* Y-Position des vierten Eckpunktes. Immer global.*/ int y4, /* Wenn <code>true<code/>, wird das Material unterirdisch gezeichnet.*/ bool sub);
//Erzeugt ein Linie zwischen zwei Punkten aus Partikeln. Rückgabewert ist die Anzahl der erzeugten Partikel.
global func int DrawParticleLine(/* Name des Partikeltyps, von dem die Partikel zu erzeugen sind*/ string particle, /* X-Position des Startpunktes. Offset bei lokalem Aufruf.*/ int x0, /* Y-Position des Startpunktes. Offset bei lokalem Aufruf.*/ int y0, /* X-Position des Endpunktes. Offset bei lokalem Aufruf.*/ int x1, /* Y-Position des Endpunktes. Offset bei lokalem Aufruf.*/ int y1, /* Abstand zwischen zwei Partikeln. Dieser Abstand kann möglicherweise nicht genau eingehalten werden, da die Partikel immer gleichmäßig auf die Strecke verteilt werden.*/ int prtdist, /* Zusatzparameter. Dies ist normalerweise die Größe des Partikels in 1/5-Pixeln.*/ int a, /* Zweiter Zusatzparameter am Startpunkt. Dies ist normalerweise die Farbmodulation des Partikels.*/ int b0, /* Zweiter Zusatzparameter am Endpunkt. Dieser Parameter wird vom Start- zum Endpunkt linear interpoliert.*/ int b1, /* Vertikale Anfangsgeschwindigkeit der Partikel*/ int ydir);
//Liefert im Entwicklermodus der Engine das Objekt, welches sich im gerade unter dem Mauscursor befindet (Modus: Objekte auswählen und verschieben).
global func object EditCursor();
//Führt einen Funktionsaufruf im angegebenen Effekt durch. Der Aufruf erhält den Befehlskontext des Effektes, und die ersten beiden Aufrufparameter sind immer Zielobjekt und Effekt. Die weiteren Parameter können frei gewählt werden.
global func any EffectCall(/* Zielobjekt des Effektes, auf dessen Variablenspeicher zugegriffen wird. <code>nil<code/> für globale Effekte.*/ object target, /* Der Effekt.*/ proplist effect, /* Aufzurufender Befehl. Es wird automatisch Fx[Effektname] vorangestellt; dies sollte nicht mit angegeben werden.*/ string command);
//Eliminiert einen Spieler. Die Runde gilt für diesen Spieler als verloren.
global func bool EliminatePlayer(/* Spielernummer des zu eliminierenden Spielers*/ int player);
//Versetzt das aufrufende Objekt in ein anderes hinein. Bei diesem Vorgang wird weder RejectCollect, noch Collection oder ActivateEntrance im Zielobjekt aufgerufen. Dafür aber RejectEntrance und Entrance im Objekt, das hineinversetzt werden soll.
global func bool Enter(/* Objekt, in das hineinversetzt wird*/ object target);
//Führt einen als String übergebenen Script aus.
global func any eval(/* Auszuführender Script*/ string script);
//Versetzt das aufrufende Objekt aus seinem Behälter heraus, und setzt optional seine Geschwindigkeit.
global func bool Exit(/* Offset der X-Austrittsposition.*/ int x, /* Offset der Y-Austrittsposition.*/ int y, /* Rotation des Austrittsobjekts in Grad.*/ int iR, /* X-Geschwindigkeit des Austrittsobjekts. Es gilt der übergebene Wert ohne Genauigkeitsteilung (Precision 1).*/ int xdir, /* Y-Geschwindigkeit des Austrittsobjekts. Es gilt der übergebene Wert ohne Genauigkeitsteilung (Precision 1).*/ int ydir, /* Rotationsgeschwindigkeit des Austrittsobjekts.*/ int rdir);
//Lässt ein Objekt explodieren. Die Explosion beschädigt Landschaft und Objekte, und das Objekt wird mitsamt Inhalt vor der Explosion entfernt. Wenn sich das Objekt in einen anderen Objekt befindet, werden alle anderen Inhaltsobjekte und das enthaltende Objekt beschädigt. Als Verursacher des Schadens gilt der Besitzer des explodierenden Objekts.
global func any Explode(/* Explosionsstärke. Die Explosionsstärke bestimmt das Ausmaß des Explosionsschadens sowie die akustische Gestaltung. Bis Stärke 29 einschließlich wird Blast1 abgespielt, von Stärke 30 bis stärke 39 einschließlich Blast2, und bei Werten darüber Blast3.*/ int level, /* Wenn angegeben, wird ein Objekt dieser Art und keine Partikel erzeugt. Es wird angenommen, dass das neu erstellte Objekt den Explosionseffekt übernimmt.*/ id effect, /* Name eines Partikels, der statt der normalen Explosionspartikel erzeugt wird.*/ string particle);
//Löscht das Feuer eines brennenden Objekts.
global func bool Extinguish();
//Saugt ein Pixel Flüssigkeit an der angegebenen Position ab. Zurückgegeben wird die Materialnummer des abgesogenen Materials; bei Misserfolg -1.
global func int ExtractLiquid(/* X-Position, an der Material extrahiert wird. Offset bei lokalem Aufruf.*/ int x, /* Y-Position, an der Material extrahiert wird. Offset bei lokalem Aufruf.*/ int y);
//Extrahiert eine bestimmte Menge des gleichen Materials an einer Stelle. Zurückgegeben wird die tatsächlich erfolgreich extrahierte Materialmenge.
global func int ExtractMaterialAmount(/* X-Position, an der Material extrahiert wird. Offset bei lokalem Aufruf.*/ int x, /* Y-Position, an der Material extrahiert wird. Offset bei lokalem Aufruf.*/ int y, /* Index des Materials, das extrahiert wird. Siehe dazu auch <funclink>Material<funclink/>.*/ int material_index, /* Maximale Menge, die extrahiert wird*/ int amount);
//Gibt die angegebene Fehlermeldung und den Aufrufstack aus und bricht dann die ausführung der aktuellen Funktion ab. FatalError kann benutzt werden, um effektiv zu debuggen oder einen Fehler bei falschen Parametern auszugeben. 
global func bool FatalError(/* Fehlermeldung, die ausgegeben wird*/ string message);
//Suchkriterium: sucht alle Objekte mit der entsprechenden Aktion.
global func array Find_Action(/* Aktion nach der gesucht werden soll*/ string action);
//Suchkriterium: findet alle Objekte mit dem entsprechenden ersten Aktionsziel.
global func array Find_ActionTarget(/* Aktionsziel von Objekten, nach denen gesucht werden soll*/ object action_target);
//Suchkriterium: findet alle Objekte mit dem entsprechenden zweiten Aktionsziel.
global func array Find_ActionTarget2(/* Aktionsziel von Objekten, nach denen gesucht werden soll*/ object action_target);
//Suchkriterium: findet alle Objekte mit den angegebenen Aktionszielen.
global func array Find_ActionTargets(/* Erstes Aktionsziel von Objekten, nach denen gesucht werden soll*/ object action_target1, /* Zweites Aktionsziel von Objekten, nach denen gesucht werden soll*/ object action_target2);
//Suchkriterium: sucht alle Objekte die Spielern gehören, die mit dem angegebenen Spieler verbündet sind.
global func array Find_Allied(/* Spielernummer, dessen Verbündete Besitzer der zu suchenden Objekte sein müssen*/ int player);
//Suchkriterium: sucht Objekte, auf die alle angegebenen Suchkriterien zutreffen.
global func array Find_And(/* Suchkriterium in Form einer Find_*-Funktion*/ array Criteria);
//Suchkriterium: sucht alle Objekte die irgendwo enthalten sind.
global func array Find_AnyContainer();
//Suchkriterium: sucht alle Objekte, deren Grafikbereich (Shape) den angegebenen Punkt überlappt.
global func array Find_AtPoint(/* X-Position des Suchpunktes. Relativ zu Objektmitte bei lokalem Aufruf.*/ int x, /* Y-Position des Suchpunktes. Relativ zu Objektmitte bei lokalem Aufruf.*/ int y);
//Suchkriterium: sucht alle Objekte mit der entsprechenden Kategorie.
global func array Find_Category(/* Objektkategorie der zu suchenden Objekte*/ int category);
//Suchkriterium: sucht alle Objekte im angegebenen Behälter.
global func array Find_Container(/* Behälter der zu findenden Objekte*/ object container);
//Suchkriterium: Sucht alle Objekte, die höchstens den angegebenen Radius vom Bezugspunkt entfernt sind. Wird kein Bezugspunkt angegeben, gilt der Mittelpunkt des aufrufenden Objektes.
global func array Find_Distance(/* Maximaler Abstand des Objektes.*/ int radius, /* Bezugspunkt für den Abstand. Bei lokalem Aufruf Offset zum aufrufenden Objekt.*/ int x, /* Bezugspunkt für den Abstand. Bei lokalem Aufruf Offset zum aufrufenden Objekt.*/ int y);
//Suchkriterium: das angegebene Objekt wird von der Suche ausgeschlossen.
global func array Find_Exclude(/* Auszuschließendes Objekt. Aufrufendes Objekt wenn nicht angegeben oder <code>nil<code/>.*/ object exclude);
//Suchkriterium: sucht alle Objekte bei denen der Aufruf der angegebenen Funktion <code>true<code/> liefert. Wenn es eine lokale Funktion gibt, wird diese aufgerufen, sonst wenn vorhanden eine globale.
global func array Find_Func(/* Aufzurufende Funktion*/ string function);
//Suchkriterium: sucht alle Objekte die Spielern gehören, die mit dem angegebenen Spieler verfeindet sind.
global func array Find_Hostile(/* Spielernummer, dessen Feinde Besitzer der zu suchenden Objekte sein müssen*/ int player);
//Suchkriterium: sucht alle Objekte mit der angegeben ID.
global func array Find_ID(/* ID der zu findenden Objekte*/ id definition);
//Suchkriterium: sucht alle Objekte im angegebenen Suchrechteck.
global func array Find_InRect(/* X-Position der linken oberen Ecke des Suchbereiches. Bei lokalem Aufruf relativ zur Objektmitte.*/ int x, /* Y-Position der linken oberen Ecke des Suchbereiches. Bei lokalem Aufruf relativ zur Objektmitte.*/ int y, /* Breite des Suchbereiches*/ int width, /* Höhe des Suchbereiches*/ int height);
//Suchkriterium: sucht alle Objekte die im Freien sind.
global func array Find_NoContainer();
//Suchkriterium: findet genau alle Objekte, die nicht das angegebene Kriterium erfüllen.
global func array Find_Not(/* Suchkriterium in Form einer Find_*-Funktion*/ array Criteria);
//Suchkriterium: Sucht alle Objekte, bei denen eine der angegebenen Object-Character-Flags gesetzt ist.
global func array Find_OCF(/* Object-Character-Flag der zu suchenden Objekte*/ int ocf);
//Suchkriterium: findet alle Objekte, deren Grafikbereich (Shape) die angegebene Linie überlappt.
global func array Find_OnLine(/* X-Position des Suchpunktes. Relativ zu Objektmitte bei lokalem Aufruf.*/ int x1, /* Y-Position des Suchpunktes. Relativ zu Objektmitte bei lokalem Aufruf.*/ int y1, /* X-Position des Endpunktes. Relativ zu Objektmitte bei lokalem Aufruf.*/ int x2, /* Y-Position des Endpunktes. Relativ zu Objektmitte bei lokalem Aufruf.*/ int y2);
//Suchkriterium: sucht alle Objekte, auf die mindestens eines der angegebenen Suchkriterien zutrifft.
global func array Find_Or(/* Suchkriterium in Form einer Find_*-Funktion*/ array Criteria);
//Suchkriterium: sucht alle Objekte die dem angegebenen Spieler gehören.
global func array Find_Owner(/* Spielernummer, der Besitzer der zu suchenden Objekte sein soll*/ int player);
//Sucht eine Heimatbasis eines Spielers. Die Heimatbasis ist zumeist das Gebäude, auf dem eine Flagge weht.
global func object FindBase(/* Spielernummer des Spielers, dessen Basis gesucht wird*/ int player, /* Suchindex, mit dem mehrere Basen eines Spielers gefunden werden können. index=0 sucht die erste Basis.*/ int index);
//Sucht einen Bauplatz für ein Gebäude, ausgehend von der angegebenen Position. Wenn ein Bauplatz gefunden wird, wird die Position als das Array [x,y] zurückgegeben. Ansonsten ist der Rückgabewert <code>nil<code/>.
global func array FindConstructionSite(/* ID des gewünschten Gebäudetyps*/ id definition, /* Gewünschte X-Position der Baustelle. Immer globale Koordinaten.*/ int x, /* Gewünschte Y-Position der Baustelle. Immer globale Koordinaten.*/ int y);
//Liefert das erste in einem Behälter enthaltene Objekt vom Typ type.
global func object FindContents(/* Objekttyp, von dem das Inhaltsobjekt sein soll*/ id type);
//Gibt ein Objekt zurück, das die angegebenen Suchkriterien erfüllt. Die Suchkriterien werden mittels speziellen Kriteriums-Funktionen der Form "Find_*" angegeben.
global func object FindObject(/* Suchkriterium in Form einer Find_*-Funktion*/ array Criteria);
//Erstellt eine Liste von Objekten, auf die alle angegeben Suchkriterien zutreffen. Die Suchkriterien werden mittels speziellen Kriteriums-Funktionen der Form "Find_*" angegeben.
global func array FindObjects(/* Suchkriterium in Form einer Find_*-Funktion*/ array Criteria);
//Liefert das erste Inhaltsobjekt eines Behälters, das nicht vom angegebenen Typ ist.
global func object FindOtherContents(/* ID des zu ignorierenden Objekttyps*/ id type);
//Beendet ein Kommado in der Kommandoliste eines Objekts.
global func bool FinishCommand(/* Ob das Kommando als erfolgreich gewertet werden soll.*/ bool success, /* Index des Kommandos. 0 für das aktuelle, 1 für das als nächstes auszuführende usw.*/ int command_num);
//Verschleudert das aufrufende Objekt in die angegebene Richtung. Diese Funktion ist für Lebewesen konzipiert, da sie die entsprechenden Aktivitäten setzt.
global func any Fling(/* X-Schleudergeschwindigkeit*/ int xdir, /* Y-Schleudergeschwindigkeit*/ int ydir);
/*

      Composes a string of several values. To do this, text is scanned for placeholders starting with '%' which are then replaced by the parameters.<br><br/>The general syntax for these placeholders is:<br><br/><code>%[length][.precision]type<code/>Except for type all fields are optional. Type specifies the data type of the parameter to be expected. It can be one of the following values: 
      <table>
        <rowh>
          <col>Typ<col/>
          <col>Bedeutung<col/>
        <rowh/>
        <row>
          <col>d<col/>
          <col>Ganzzahl (int)<col/>
        <row/>
        <row>
          <col>x<col/>
          <col>Ganzzahl (int), hexadezimale Ausgabe (0123456789abcdef)<col/>
        <row/>
        <row>
          <col>X<col/>
          <col>Ganzzahl (int), hexadezimale Ausgabe (0123456789ABCDEF)<col/>
        <row/>
        <row>
          <col>i<col/>
          <col>id (Bei IDs funktionieren die restlichen Parameter wie Länge und Präzision nicht!)<col/>
        <row/>
        <row>
          <col>s<col/>
          <col>Zeichenkette<col/>
        <row/>
        <row>
          <col>v<col/>
          <col>Beliebig. Vor allem nützlich zur Fehlersuche.<col/>
        <row/>
      <table/>
 Length specifies the minimum number of characters used to display the value. If the value is shorter, the display is padded on the left with space characters, or with zeroes if there is a '0' before the length specification.<br><br/><br><br/>The meaning of the precision field varies with the data type: for integers (d) it specifies the minimum display length (the number is padded with zeroes at the beginning); however for strings (s) it specifies the maximum number of characters to be displayed.<br><br/>
    
*/
global func string Format(/* Zeichenkette, in die die Werte eingesetzt werden*/ string text);
//Gibt die Nummer des Frames zurück, in dem sich das Spiel befindet. Dieser Zähler beginnt beim Szenarienstart mit 0, und zählt dann mit ca. 37 Frames pro Sekunde hoch (abhängig von der Spielgeschwindigkeit)
global func int FrameCounter();
//Entfernt alle Materialien innerhalb des angegebenen Rechtecks. Die Koordinaten sind immer global, und der untere und rechte Rand des Rechtecks zählen nicht mit dazu.
global func any FreeRect(/* Linke Kante des Rechtecks*/ int x, /* Obere Kante des Rechtecks*/ int y, /* Breite des Rechtecks*/ int width, /* Höhe des Rechtecks*/ int height, /* Wenn angegeben, wird Material mit der entsprechenden Dichte entfernt*/ int density);
//Fügt ein Passwort in die Liste der Missionszugänge ein. Alle Spieler auf dem selben Computer können dann ein Szenario starten, welches in der Scenario.txt dieses Passwort als Voraussetzung enthält. Sinnvollerweise sollte jedes Szenario in einer Reihe von Missionen bei erfolgreichem Beenden der Runde das für die jeweils nächste Mission benötigte Passwort freigeben.
global func bool GainMissionAccess(/* Passwort, das der Liste hinzugefügt wird.*/ string password);
//Ruft function im Szenario-Script auf. Falls die Funktion nicht im Szenario-Script vorhanden ist, gibt die Funktion <code>nil<code/> zurück und verursacht keine Fehlermeldung.
global func any GameCall(/* Name der Funktion im Szenario-Script*/ string function);
//Macht einen Broadcast-Aufruf an das Szenarioscript, alle Spielziele, -regeln und Umweltobjekte. Dies ist das gleiche was die Engine macht wenn sie einen Szenario-Callback macht. Siehe <emlink>Szenario Script Callbacks<emlink/>.
global func any GameCallEx(/* Name der Scriptfunktion*/ string function);
//Beendet die Runde. Die Runde wird für alle überlebenden Spieler als gewonnen gewertet.
global func bool GameOver();
//Überprüft ob sich an angegebener Position in der Landschaft Flüssigkeit befindet.
global func bool GBackLiquid(/* X-Koordinate, Offset bei lokalem Aufruf*/ int x, /* Y-Koordinate, Offset bei lokalem Aufruf*/ int y);
//Überprüft ob sich an angegebener Position in der Landschaft feste Materie oder Flüssigkeit befindet. Also alles außer Himmel und Tunnel.
global func bool GBackSemiSolid(/* X-Koordinate, Offset bei lokalem Aufruf*/ int x, /* Y-Koordinate, Offset bei lokalem Aufruf*/ int y);
//Überprüft ob sich an angegebener Position in der Landschaft Himmel befindet.
global func bool GBackSky(/* X-Koordinate, Offset bei lokalem Aufruf*/ int x, /* Y-Koordinate, Offset bei lokalem Aufruf*/ int y);
//Überprüft ob sich an angegebener Position in der Landschaft feste Materie befindet. Also alles wo Objekte nicht durchkönnen.
global func bool GBackSolid(/* X-Koordinate, Offset bei lokalem Aufruf*/ int x, /* Y-Koordinate, Offset bei lokalem Aufruf*/ int y);
//Liefert den Namen der momentanen Aktivität eines Objekts zurück, "Idle", wenn das Objekt keine Aktivität ausführt.
global func string GetAction();
//Liefert die aktuellen Aktivitätszielobjekte des aufrufenden Objekts.
global func object GetActionTarget(/* 0 für target oder 1 für target2*/ int index);
//Fragt Aktionsdaten aus der <emlink>ActMap<emlink/> anhand deren dortigem Namen ab.
global func any GetActMapVal(/* Name des abzufragenden Eintrags*/ string entry, /* Name der Aktion, von der der Eintrag abgefragt werden soll*/ string action, /* Objektdefinition, von der die Aktionsdaten abgefragt werden sollen. Wenn nicht angegeben wird die Definition des aufrufenden Objekts angenommen.*/ id definition, /* Nummer des abzufragenden Wertes, wenn der Eintrag mehrere Werte enthält.*/ int entry_number);
//Liefert den Zeitraum in Frames, die das aufrufende Objekt bereits die aktuelle Aktivität ausgeführt hat.
global func int GetActTime();
//Gibt zurück, ob das aufrufende Objekt noch am Leben ist.
global func bool GetAlive();
//Gibt die Länge der Animation mit dem angegebenen Namen zurück, oder <code>nil<code/> wenn keine solche Animation existiert. Gültige Positionen (für <funclink>PlayAnimation<funclink/> und <funclink>SetAnimationPosition<funclink/>) liegen zwischen 0 und der Länge der Animation. Die zurückgegebene Zahl entspricht der Animationslänge (wie sie im Modellierungstool eingestellt wurde) in Millisekunden.
global func int GetAnimationLength(/* Name der Animation deren Länge abgefragt werden soll.*/ string animation);
//Gibt den Namen der Animation mit der angegebenen Nummer zurück. Falls keine Animation mit der angegebenen Nummer existiert, oder falls es sich dabei um einen Kombinationsknoten handelt gibt die Funktion <code>nil<code/> zurück.
global func string GetAnimationName(/* Animationsnummer der Animation deren Name abgefragt werden soll.*/ int animation_number);
//Gibt die Stelle zurück an der die Animation mit der angegebenen Nummer gerade ist. Die Zahl liegt zwischen 0 und <funclink>GetAnimationLength<funclink/>(<funclink>GetAnimationName<funclink/>(animation_number)). Falls es keine Animation mit der angegebenen Nummer gibt oder es sich dabei um einen Kombinationsknoten handelt gibt die Funktion <code>nil<code/> zurück.
global func int GetAnimationPosition(/* Animationsnummer der Animation deren Position abgefragt werden soll.*/ int animation_number);
//Gibt die Gewichtung eines Kombinationsknotens zurück. Die Gewichtung bestimmt, zu welchem Anteil die beiden kombinierten Animationen in die Gesamtanimation einfließen. Die Zahl liegt immer zwischen 0 (erste Animation geht voll ein) und 1000 (zweite Animation geht voll ein). Gibt <code>nil<code/> zurück falls es keine Animation mit der angegebenen Nummer gibt, oder falls es sich dabei um einen Animationsknoten handelt.
global func int GetAnimationWeight(/* Animationsnummer der Animation deren Gewichtung abgefragt werden soll.*/ int animation_number);
//Liefert die Nummer des Spielers, dessen Heimatbasis das aufrufende Objekt ist. Rückgabewert <funclink>NO_OWNER<funclink/> wenn es keine Heimatbasis ist.
global func int GetBase();
//Gibt den Wert des bit_number'nten Bits zurück.
global func bool GetBit(/* Alter Wert der Bitmaske*/ int old_value, /* Das abzufragende Bit*/ int bit_number);
//Gibt den momentanen Atemwert des Objektes zurück. Dies ist die Anzahl der Frames die ein Objekt noch seinen Atem halten kann.
global func int GetBreath();
//Fragt die Objektkategorie des aufrufenden Objekts oder der aufrufenden Definition ab. Die Objektkategorie wird normalerweise über die <emlink>DefCore<emlink/> gesetzt, und danach höchstens in seltenen Fällen mit <funclink>SetCategory<funclink/> geändert. Sie bestimmt das allgemeine Verhalten eines Objekts und dessen Platzierung. Eine mit GetCategory abgefragt Kategorie kann mit dem &-Operator gegen eine C4D_-Konstante geprüft werden.
global func int GetCategory();
//Ermittelt den Zeichencode eines indizierten Zeichens einer Zeichenkette.
global func int GetChar(/* Zeichenkette, von der ein Zeichen abgefragt wird*/ string text, /* Position des abgefragten Zeichens. 0 entspricht dabei dem ersten Zeichen. Ist dieser Wert größer oder gleich der Länge der Zeichenkette, wird <code>nil<code/> zurückgegeben.*/ int index);
//Liefert den aktuellen Klimawert. Dieser wird als Konstante zum durch TemperatureRange und Season entstehenden Wert hinzugezählt.
global func int GetClimate();
//Fragt die Farbmodulation des aufrufenden Objekts ab. Diese ist ein Farbwert, der multiplikativ (oder auch additiv, bei entsprechend aktiviertem BlitMode in der DefCore) aufgerechnet wird. Für weitere Hinweise siehe auch <funclink>SetClrModulation<funclink/>().
global func int GetClrModulation(/* Wenn angegeben, wird stattdessen die Farbmodulation dieses Grafikoverlays abgefragt. Das Overlay muss vorher mit <funclink>SetGraphics<funclink/> erstellt worden sein.*/ int overlay_id);
//Fragt den RGB-Farbwert der Färbung der ColorByOwner-Flächen des aufrufenden Objekts ab. Diese werden beispielsweise durch <funclink>SetOwner<funclink/> oder <funclink>SetColor<funclink/> gesetzt.
global func int GetColor();
//Liefert die aktuelle Befehlsrichtung des aufrufenden Objekts. Diese gibt die momentane, beabsichtigte Bewegungsrichtung an. Die Auswirkung dieser Richtung hängt von der <emlink>Prozedur<emlink/> der aktuellen <emlink>Aktivität<emlink/> ab.
global func int GetComDir();
//Gibt Informationen über ein Kommando des aufrufenden Objekts zurück. Führt das Objekt momentan keine Aktion aus, so wird (bei jedem Wert von element) <code>nil<code/> zurückgegeben.
global func any GetCommand(/* Information, die zurückgegeben werden soll. 0 oder kA: Name, 1: Target, 2: TargetX, 3: TargetY, 4: Target2, 5: Data*/ int element, /* Nummer des Kommandos. 0 steht für das momentan aktive, 1 für das danach auszuführende usw.*/ int command_num);
//Liefert Objektkomponenten.
global func any GetComponent(/* Objektkomponente, dessen Menge zurückgeliefert werden soll. Wenn 0, wird index benutzt und eine Objektkomponente zurückgegeben.*/ id component, /* Index der zurückzuliefernden Komponente. Dieser Parameter wird ignoriert, wenn component angegeben ist. Ansonsten wird eine ID der Komponente zurückgegeben, dessen Menge in einem darauffolgenden GetComponent-Aufruf ermittelt werden kann.*/ int index, /* Objekt dessen Komponenten abgefragt werden sollen. <code>nil<code/> bei lokalem Aufruf. Wenn stattdessen eine definition angegeben ist, wird dieser Parameter ignoriert.*/ object obj, /* Definition, von der die Komponenten abgefragt werden sollen. Wenn <code>nil<code/>, wird stattdessen in obj bzw. dem aufrufenden Objekt abgefragt.*/ id definition);
//Liefert die Fertigstellung des aufrufenden Objekts in Prozent. Bei Baustellen ist dies die Fertigstellung, während es bei Tieren und Pflanzen die Größe angibt (Siehe StretchGrowth/OverSize in der <emlink>DefCore<emlink/>)
global func int GetCon();
//Ermittelt, in welche Richtungen einzelne oder alle Vertices des aufrufenden Objekts feste Landschaft berühren. Die Richtungen werden als Bitmaske von <emlink>CNAT-Werten<emlink/> übergeben bzw. von der Funktion zurückgegeben.
global func int GetContact(/* Index des abzufragenden Vertex. -1 prüft alle Vertices, und gibt das Ergebnis als eine mit binärem Oder kombinierte Bitmaske zurück.*/ int index, /* Bitmaske von CNAT-Werten, die angeben, welche Richtungen geprüft werden sollen. Wenn nicht angegeben werden alle Richtungen geprüft.*/ int dwCNAT);
//Fragt ab, welcher Spieler das aufrufende Objekt zur Zeit kontrolliert bzw. zuletzt kontrolliert hat. Bei Mannschaftsmitgliedern ist dies normalerweise immer der Besitzer; bei Fahrzeugen der Controller des Clonks, der es zuletzt bedient (angefasst und geschoben/gezogen) hat. Objekte, die von Lebewesen aufgenommen werden, nehmen automatisch den Controller ihres Containers an. Beim Besitzerwechsel (siehe <funclink>SetOwner<funclink/>())wird automatisch auch der Controller auf den neuen Besitzer geändert.
global func int GetController();
//Gibt ein Mannschaftsmitglied eines Spielers zurück. Wird ein ungültiger Index angegeben, gibt die Funktion <code>nil<code/> zurück.
global func object GetCrew(/* Spielernummer des Spielers, dessen Mannschaftsmitglied zurückgegeben werden soll.*/ int player, /* Index des Clonks in der Crew*/ int index);
//Liefert die Anzahl der Mannschaftsmitglieder eines Spielers zurück.
global func int GetCrewCount(/* Spielernummer des Spielers, dessen Mannschaftsmitglieder gezählt werden sollen.*/ int player);
//Fragt ab, ob ein Mannschaftsmitglied gegenwärtig angewählt werden kann.
global func bool GetCrewEnabled();
//Dieser Befehl fragt im Clonk in der Spielerdatei gespeicherten Extra-Daten ab, die per <funclink>SetCrewExtraData<funclink/> gesetzt wurden.
global func any GetCrewExtraData(/* Name der zugeordneten Daten.*/ string data_name);
//Gibt den momentan kontrollierten Clonk eines Spielers zurück.
global func object GetCursor(/* Spielernummer des Spielers, dessen kontrollierter Clonk zurückgegeben werden soll.*/ int player);
//Fragt den Schadenswert des aufrufenden Objekts ab.
global func int GetDamage();
//Fragt die Unterkante des aufrufenden Objekts ab. Diese entspricht Y-Position + DefCore-OffsetY + DefCore-Height. Eine eventuelle Drehung wird hier nicht mit eingerechnet.
global func int GetDefBottom();
//Gibt einen Eigenschaftswert der aufrufenden Objektdefinition nach seinem Namen in der <emlink>DefCore.txt<emlink/> zurück.
global func any GetDefCoreVal(/* Name des abzufragenden Eintrags*/ string entry, /* Sektion des abzufragenden Eintrags. Wenn nicht angegeben, werden alle Sektionen nach einem Eintrag mit dem entspr. Namen durchsucht.*/ string section, /* Nummer des abzufragenden Wertes, wenn der Eintrag mehrere Werte enthält.*/ int entry_number);
//Liefert das ID der indizierten von der Engine in dieser Runde geladenen Objektdefinition der angegebenen Kategorie.
global func id GetDefinition(/* Index der gesuchten Definition.*/ int index);
//Liefert die aktuelle Richtung des aufrufenden Objekts als DIR_x-Wert.
global func int GetDir();
//Gibt einen bestimmten Effekt zurück. Wurde der Effekt nicht gefunden, wird <code>nil<code/> zurückgegeben.
global func any GetEffect(/* Name des Effektes ohne vorangestelltes Fx. Es können '*' und '?' als Suchmaske verwendet werden.*/ string name, /* Zielobjekt, in dem Effekte abgefragt werden sollen. Bei <code>nil<code/> wird die globale Effektliste durchsucht.*/ object target, /* Effektindex. Bei angegebenem name gibt dies bei mehreren, der Suchmaske entsprechenden Effekten den indizierten Effekt in der Liste der passenden Effekte an.*/ int index, /* Wenn ungleich 0, werden nur Effekte zurückgegeben, die höchstens die angegebene Priorität haben.*/ int max_priority);
//Zählt die Effekte in einem Objekt oder globale Effekte.
global func int GetEffectCount(/* Suchmaske für den Namen der Effekte. Es können '*' und '?' in der Maske verwendet, oder auch direkt Effektnamen angegeben werden. Wenn nicht angegeben, werden alle Effekte gezählt.*/ string mask, /* Zielobjekt, dessen Effekte gezählt werden sollen. Bei unspecified werden globale Effekte gezählt.*/ object target, /* Wenn ungleich 0, werden nur Effekte zurückgegeben, die höchstens die angegebene Priorität haben.*/ int max_priority);
//Liefert den aktuellen Energiewert des aufrufenden Objekts in Prozent. 100% stellen hierbei den maximalen Physical-Wert von 100000 dar. Siehe auch DefCore.txt Sektion [Physical].
global func int GetEnergy();
//Liefert den aktuellen Eintrittsstatus des aufrufenden Objekts. <code>true<code/> bei erlaubtem Eintritt, <code>false<code/> bei verbotenem Eintritt.
global func bool GetEntrance();
//Liest die Schwerkraft (in Prozent) aus.
global func int GetGravity();
//Liefert den höchstrangigen aktiven Clonk von player.
global func object GetHiRank(/* Spieler*/ int player);
//Bei angegebenen id gibt die Funktion die Menge der Objekte zurück, die der Spieler in seiner Heimatbasis kaufen kann. index und category werden hierbei ignoriert. Wird id nicht angegeben, liefert die Funktion den indizierten Objekttyp der entsprechenden Kategorie der kaufbaren Objekte des Spielers. Der Objekttyp (id) taucht in der Liste auf und wird zurückgeliefert, selbst wenn zur Zeit keine Objekte dieses Typs verfügbar sind.
global func int GetHomebaseMaterial(/* Die Nummer des Spieler, dessen Kaufmöglichkeiten abgefragt werden sollen. Der erste Spieler hat die Nummer 0.*/ int player, /* Wenn angegeben, gibt die Funktion die Menge der Objekte zurück, die der Spieler in seiner Heimatbasis kaufen kann. index und category werden hierbei ignoriert.*/ id id, /* Der Index der gesuchten Kaufmöglichkeit.*/ int index, /* Die Kategorie der gesuchten Kaufmöglichkeit.*/ int category);
//Bei angegebenen id gibt die Funktion zurück, wie schnell die Menge der Objekte in der Heimatbasis des Spielers nachgeliefert wird. index und category werden hierbei ignoriert. Wird id nicht angegeben, liefert die Funktion den indizierten Objekttyp der entsprechenden Kategorie der nachgelieferten Objekte des Spielers. Der Objekttyp (id) taucht in der Liste auf und wird zurückgeliefert, selbst wenn zur Zeit keine Objekte dieses Typs nachgeliefert werden.
global func int GetHomebaseProduction(/* Die Nummer des Spielers, dessen Kaufmöglichkeiten abgefragt werden sollen. Der erste Spieler hat die Nummer 0.*/ int player, /* Wenn angegeben, gibt die Funktion die Menge der Objekte zurück, die in der Heimatbasis des Spielers nachgeliefert wird. index und category werden hierbei ignoriert.*/ id id, /* Der Index der gesuchten Kaufmöglichkeit.*/ int index, /* Die Kategorie der gesuchten Kaufmöglichkeit.*/ int category);
//Gibt die ID des aufrufenden Objekts zurück.
global func id GetID();
//
global func int GetIndexOf(/* */ array array2search, /* */ needle);
//Liefert den Spieler, der zuletzt Energieabzug am aufrufenden Objekt verursacht hat.
global func int GetKiller();
//Ermittelt die Länge einer Zeichenkette oder eines Arrays.
global func int GetLength(/* Zeichenkette oder Array, von der die Länge abgefragt wird*/ text);
//Liefert die Masse des aufrufenden Objekts (inklusive aller Inhaltsobjekte) oder der aufrufenden Definition.
global func int GetMass();
//Fragt das Material an einer bestimmten Stelle der Landschaft ab. Der zurückgegebene Wert ist ein Materialindex, der mit anderen Indizes zum Beispiel über die Funktion <funclink>Material<funclink/>() verglichen werden kann. Für Himmel gibt die Funktion -1 zurück.
global func int GetMaterial(/* X-Position, an der das Material abgefragt werden soll. Offset bei lokalem Aufruf.*/ int x, /* Y-Position, an der das Material abgefragt werden soll. Offset bei lokalem Aufruf.*/ int y);
//Liefert die in der Landschaft vorhandene Menge des angegebenen Materials.
global func int GetMaterialCount(/* Materialsindex*/ int material_index);
//Gibt einen Eigenschaftswert einer Materialdefinition nach seinem Namen in der <emlink>Materialdatei<emlink/> zurück.
global func any GetMaterialVal(/* Name des abzufragenden Eintrags*/ string entry, /* Sektion des abzufragenden Eintrags. Wenn nicht angegeben, werden alle Sektionen nach einem Eintrag mit dem entspr. Namen durchsucht.*/ string section, /* Nummer des Materials, von dem der Eintrag abgefragt werden soll. Bei Übergabe von 0 wird die Definition des aufrufenden Objekts angenommen.*/ int material, /* Nummer des abzufragenden Wertes, wenn der Eintrag mehrere Werte enthält.*/ int entry_number);
//Liefert die ID des Menüs, falls das Objekt ein Menü geöffnet hat. Normalerweise ist das die ID des Menüsymbols (symbol), wenn nicht bei <funclink>CreateMenu<funclink/> explizit eine andere Menü-ID als idMenuID angegeben wurde.
global func any GetMenu();
//Ermittelt den gerade ausgewählten Menüeintrag des geöffneten Menüs des aufrufenden Objekts, oder <code>nil<code/>, wenn kein Menü geöffnet ist.
global func any GetMenuSelection();
//Gibt zurück, welches Material das Mesh des aufrufenden Objekts gerade gesetzt hat.
global func string GetMeshMaterial(/* Besteht das Mesh aus mehreren SubMeshes, so kann durch diesen Parameter angegeben werden das Material welches SubMeshes abgefragt werden soll.*/ int submesh);
//Stellt fest und gibt zurück, ob der Spieler bereits das angegebene Missionszugangspasswort besitzt
global func bool GetMissionAccess(/* Missionszugang, der überprüft wird*/ string mission_access);
//Gibt den Namen eines Objekts oder einer Objektdefinition zurück. Hat das Objekt keinen eigenen Namen, wird der Name der Definition zurückgegeben.
global func string GetName();
//Liefert die noch benötigten Baumaterialien des Objekts
global func string GetNeededMatStr();
//Liefert den aktuellen Zeichenmodus des aufrufenden Objekts.
global func int GetObjectBlitMode(/* Wenn angegeben, wird stattdessen der Blitmodus dieses Grafikoverlays abgefragt. Das Overlay muss vorher mit <funclink>SetGraphics<funclink/> erstellt worden sein.*/ int overlay_id);
//Bei dem InfoCore handelt es sich um die Informationen eines CrewMembers, die in dem Spieler gespeichert werden (*.oci). Dementsprechend gibt GetObjectInfoCoreVal einen Eigenschaftswert eines Crewmembers nach Namen in einer oci-Datei zurück
global func any GetObjectInfoCoreVal(/* Name des abzufragenden Eintrags*/ string entry, /* Sektion des abzufragenden Eintrags. Wenn nicht angegeben, werden alle Sektionen nach einem Eintrag mit dem entspr. Namen durchsucht.*/ string section, /* Nummer des abzufragenden Wertes, wenn der Eintrag mehrere Werte enthält.*/ int entry_number);
//Gibt einen Eigenschaftswert des aufrufenden Objekts nach seinem Namen in der Objects.txt zurück.
global func any GetObjectVal(/* Name des abzufragenden Eintrags*/ string entry, /* Sektion des abzufragenden Eintrags. Wenn nicht angegeben, werden alle Sektionen nach einem Eintrag mit dem entspr. Namen durchsucht.*/ string section, /* Nummer des abzufragenden Wertes, wenn der Eintrag mehrere Werte enthält.*/ int entry_number);
//Liefert das Object-Character-Flag des aufrufenden Objekts. Dieser Wert beschreibt den aktuellen Zustand des Objekts. Der Rückgabewert ist eine Bitmaske und kann mit & mit einem OCF_x-Wert verglichen werden.
global func int GetOCF();
//Ermittelt den Besitzer des aufrufenden Objekts.
global func int GetOwner();
//Sucht mittels des auch für die Clonk-Wegfindung benutzten Algorithmus einen Weg zwischen zwei Punkten der Landschaft und gibt dessen Länge zurück. Wurde kein Weg gefunden, gibt die Funktion <code>nil<code/> zurück.
global func int GetPathLength(/* Y-Koordinate der Startposition. Immer globale Koordinaten.*/ int startx, /* Y-Koordiante der Startposition. Immer globale Koordinaten.*/ int starty, /* X-Koordiante der Zielposition. Immer globale Koordinaten.*/ int endx, /* Y-Koordiante der Zielposition. Immer globale Koordinaten.*/ int endy);
//Liefert die Aktivitätsphase des aufrufenden Objekts.
global func int GetPhase();
//Liefert die physischen Eigenschaften des Objekts oder der Definition im Aufrufkontext.
global func int GetPhysical(/* Name der abzufragenden physischen Eigenschaft.*/ string physical, /* 
            Change mode:<br><br/>
            <table>
              <rowh>
                <col>Konstante<col/>
                <col>Wert<col/>
                <col>Bedeutung<col/>
              <rowh/>
              <row>
                <col>PHYS_Current<col/>
                <col>0<col/>
                <col>Im Objektkontext: Die Eigenschaften werden im gerade aktiven Modus (temporär oder permanent) des Objektes abgefragt. Dieser Modus funktioniert als einziger auch bei Objekten ohne Objektinfo. Im Definitionskontext: Die Standardwerte der Definition werden abgefragt.<col/>
              <row/>
              <row>
                <col>PHYS_Permanent<col/>
                <col>1<col/>
                <col>Die permanenten Eigenschaften aus der Spielerdatei werden abgefragt. Dies ist nur bei Spielercrew-Mitgliedern möglich.<col/>
              <row/>
              <row>
                <col>PHYS_Temporary<col/>
                <col>2<col/>
                <col>Die temporären Eigenschaften werden abgefragt, wenn sie existieren.<col/>
              <row/>
            <table/>

          */ int mode);
//Gibt die indizierte Spielernummer zurück. Die Funktion garantiert für Werte zwischen 0 und GetPlayerCount()-1, dass eine gültige Spielernummer zurückgegeben wird (denn durch eliminierte Spieler und Neubeitritte kann es vorkommen, dass "Löcher" unbelegter Spielernummern in der Liste entstehen!). Damit ist es einfacher, eine Schleife zu schreiben, die alle Spielernummern durchgeht.
global func int GetPlayerByIndex(/* Index in der Spielerliste*/ int index, /* Wenn angegeben, wird der indizierte Spieler des angegebenen Typs zurückgegeben. So lassen sich zum Beispiel nur alle menschlichen oder nur alle Scriptspieler durchgehen. Für eine Liste gültiger Werte, siehe <funclink>GetPlayerType<funclink/>.*/ int player_type);
//Gibt die Spielernummer des angegebenen Spielers oder -1 wenn kein solcher Spieler gefunden wurde zurück.
global func int GetPlayerByName(/* Name des Spielers*/ string player_name);
//Liefert den Namen eines Spielers mit Markup in dessen Spielerfarbe. Wenn die Spielernummer zu keinem gültigen Spieler gehört, wird <code>nil<code/> zurückgegeben. Dadurch kann diese Funktion auch benutzt werden, um zu ermitteln, ob eine Spielernummer gültig ist.
global func string GetPlayerControlAssignment(/* Spielernummer, dessen Verbündete Besitzer der zu suchenden Objekte sein müssen*/ int player, /* */ int control, /* */ bool human_readable, /* */ bool short_name);
//Liefert die Anzahl der Spieler, die momentan im Spiel sind.
global func int GetPlayerCount(/* Wenn angegeben, wird nur die Anzahl des Spielers vom angegebenen Typ zurückgegeben. Für eine Liste gültiger Spielertypen siehe <funclink>GetPlayerType<funclink/>.*/ int player_type);
//Gibt die Spieler-ID eines beigetretenen Spielers zurück. Spieler-IDs werden von 1 hochgezählt, und - anders als Spielernummern - nicht wieder benutzt, nachdem ein Spieler eliminiert wurde. Jeder neu beigetetene Spieler hat also eine eigene ID.
global func int GetPlayerID(/* Spielernummer, dessen ID abgefragt werden soll.*/ int player);
//Gibt einen Eigenschaftswert aus der Player.txt eines Spielers zurück.
global func any GetPlayerInfoCoreVal(/* Name des abzufragenden Eintrags*/ string entry, /* Sektion des abzufragenden Eintrags. Wenn nicht angegeben, werden alle Sektionen nach einem Eintrag mit dem entspr. Namen durchsucht.*/ string section, /* Spieler, dessen Eintrag abgefragt werden soll.*/ int player, /* Nummer des abzufragenden Wertes, wenn der Eintrag mehrere Werte enthält.*/ int entry_number);
//Liefert den Namen eines Spielers. Wenn die Spielernummer zu keinem gültigen Spieler gehört, wird <code>nil<code/> zurückgegeben. Dadurch kann diese Funktion auch benutzt werden, um zu ermitteln, ob eine Spielernummer gültig ist.
global func string GetPlayerName(/* Spielernummer des Spieler, dessen Name abgefragt werden soll*/ int player);
//Liefert die Punkte die player hat.
global func int GetPlayerScore(/* Spieler-Nummer dessen Punkte zurück gegeben werden sollen.*/ int player);
//Liefert die Änderung der Spielerpunkte seit Beginn der Runde.
global func int GetPlayerScoreGain(/* Spieler, dessen Spielerpunktegewinn gesucht wird.*/ int player);
//Liefert das Team eines Spielers. Hat der Spieler kein Team, wird 0 zurückgegeben.
global func int GetPlayerTeam(/* Spielernummer des Spieler, dessen Team abgefragt werden soll*/ int player);
/*

      Returns the type of a player. Possible values are: 
      <table>
        <rowh>
          <col>Konstante<col/>
          <col>Wert<col/>
          <col>Beschreibung<col/>
        <rowh/>
        <row>
          <col>C4PT_User<col/>
          <col>1<col/>
          <col>Vom Benutzer gesteuerter Spieler<col/>
        <row/>
        <row>
          <col>C4PT_Script<col/>
          <col>2<col/>
          <col>Scriptgeesteuerter Spieler; zum Beispiel KI-Spieler.<col/>
        <row/>
      <table/>

    
*/
global func int GetPlayerType(/* Spielernummer des Spieler, dessen Typ abgefragt werden soll*/ int player);
//Fragt Eigenschaftswerte eines Spielers anhand dessen Namen ab, wie sie beim Speichern eines Spiels in die game.txt geschrieben werden
global func any GetPlayerVal(/* Name des abzufragenden Eintrags*/ string entry, /* Sektion des abzufragenden Eintrags. Wenn nicht angegeben, werden alle Sektionen nach einem Eintrag mit dem entspr. Namen durchsucht.*/ string section, /* Nummer des Spielers, von dem der Eintrag abgefragt werden soll.*/ int player, /* Nummer des abzufragenden Wertes, wenn der Eintrag mehrere Werte enthält.*/ int entry_number);
//
global func int GetPlrClonkSkin(/* Abgefragter Spieler*/ int player);
//Fragt die Spielerfarbe ab. Die Spielerfarbe wird verwendet, um einige Besitzobjekte wie Clonks oder Flaggen, sowie Textnachrichten dieses Spielers einzufärben.
global func int GetPlrColor(/* Abgefragter Spieler*/ int player);
//Dieser Befehl fragt im Spieler gespeicherten Extra-Daten ab, die per <funclink>SetPlrExtraData<funclink/> gesetzt wurden.
global func any GetPlrExtraData(/* Nummer des Spielers, für den zusätzliche Daten gespeichert werden sollen*/ int player, /* Name der zugeordneten Daten.*/ string data_name);
//Bei angegebenen <code>type<code/> gibt die Funktion <code>true<code/> zurück, wenn der Spieler den Bauplan des betreffenden herstellbaren Objekts besitzt. <code>index<code/> und <code>category<code/> werden hierbei ignoriert. Andernfalls liefert die Funktion den indizierten Bauplan der entsprechenden Kategorie des Spielers.
global func int GetPlrKnowledge(/* Spieler, über dessen Baupläne Informationen abgerufen werden sollen.*/ int player, /* Wenn angegebenen, dann gibt die Funktion <code>true<code/> zurück, wenn der Spieler den Bauplan des betreffenden herstellbaren Objekts besitzt, ansonsten <code>false<code/>.*/ id type, /* Wenn <code>type<code/> nicht angegeben ist, ist dies der Index des Bauplans von der Liste der Baupläne.*/ int index, /* Wenn <code>type<code/> nicht angegeben ist, grenzt dies die Kategorie der Baupläne ein.*/ int category);
//Stellt das Magiewissen eines bestimmten Spielers fest.
global func any GetPlrMagic(/* Spieler, dessen Magiewissen abgefragt wird.*/ int player, /* Bei angegebenen id gibt die Funktion <code>true<code/> zurück, wenn der player betreffenden Zauber zur Verfügung hat. index wird hierbei ignoriert.*/ id id, /* Bei angegebenem index liefert die Funktion den indizierten Zauberspruch, der dem Spieler zur Verfügung steht.*/ int index);
//Gibt das Objekt zurück, dem die Sicht eines Spielers folgt. Gibt <code>nil<code/> zurück, wenn kein Spieler mit der angegebenen Nummer existiert oder die Spielersicht keinem per Script gesetztem Objekt folgt (siehe <funclink>GetPlrViewMode<funclink/>).
global func object GetPlrView(/* Nummer des Spielers, dessen Sicht abgefragt werden soll.*/ int player);
/*

      Determines the current view mode of a player. The function returns the following values: 
      <ul>
        <li>0: Cursor - Die Sicht des Spielers folgt dem aktuell selektierten Clonk (siehe <funclink>GetCursor<funclink/>)<li/>
        <li>1: Target - Die Sicht folgt einem anderen Objekt, welches durch den Befehl <funclink>SetPlrView<funclink/> im Script gesetzt wurde. Siehe auch <funclink>GetPlrView<funclink/>.<li/>
        <li>2: Scroll - Der Spieler bewegt seine Sicht unabhängig von der Position eines Objekts. Dies geschieht, wenn der Spieler die Maus an den Rand seines Sichtbereichs zieht.<li/>
      <ul/>

    
*/
global func int GetPlrViewMode(/* Nummer des Spielers, dessen Sichtmodus abgefragt werden soll.*/ int player);
//Gibt die Prozedur der gegenwärtigen Aktivität des aufrufenden Objekts zurück (z.B. FLOAT, ATTACH, etc.). Bei einer NONE-Prozedur oder keiner Aktivität wird <code>nil<code/> zurückgegeben.
global func string GetProcedure();
//Liefert die Eigenschaft <code>key<code/> von <code>object<code/>.
global func array GetProperties(/* Objekt von dem die Eigenschaft abgefragt wird. <code>nil<code/> für lokale Aufrufe.*/ proplist object);
//Liefert die Eigenschaft <code>key<code/> von <code>object<code/>.
global func any GetProperty(/* Abzufragende Eigenschaft.*/ string key, /* Objekt von dem die Eigenschaft abgefragt wird. <code>nil<code/> für lokale Aufrufe.*/ proplist object);
//Liefert die Rotation des aufrufenden Objekts in Grad. Der Rückgabewert liegt zwischen -180° und 180°. 0° ist der Normalzustand.
global func int GetR();
//Liefert die Rang-Nummer des aufrufenden Objekts. 0 ist ein unbeförderter Clonk.
global func int GetRank();
//Liefert die Rotations-Geschwindigkeit des aufrufenden Objekts.
global func int GetRDir(/* Genauigkeit. Keine Angabe entspricht 10.*/ int precision);
/*

      Returns one of the three color fractions of the specified 32 bit color value: 
      <table>
        <rowh>
          <col>select<col/>
          <col>Rückgabewert<col/>
        <rowh/>
        <row>
          <col>0<col/>
          <col>Alpha-Wert<col/>
        <row/>
        <row>
          <col>1<col/>
          <col>Rotanteil<col/>
        <row/>
        <row>
          <col>2<col/>
          <col>Grünanteil<col/>
        <row/>
        <row>
          <col>3<col/>
          <col>Blauanteil<col/>
        <row/>
      <table/>

    
*/
global func int GetRGBaValue(/* 32Bit-Farbwert*/ int Val, /* 0-3: Auswahl des gewünschten Rückgabewerts*/ int select);
//Gibt die Nummer der obersten Animation im angegebenen Slot zurück. Diese Animation wird mit der Animation der nächstkleineren Slotnummer kombiniert um dann mit der obersten Animation der nächsthöheren Slotnummer kombiniert zu werden, oder, falls es keinen nächsthöheren Slot gibt, auf dem Bildschirm angezeigt zu werden. Enthält der Slot mehr als eine Animation, so ist die oberste Animation immer ein Kombinationsknoten, der die Einzelanimationen oder Kombinationen derselben zu dem Gesamtergebnis des Slots kombiniert. Gibt <code>nil<code/> zurück wenn der angegebene Slot gar keine Animation enthält.
global func int GetRootAnimation(/* Slot dessen oberste Animation zurückgegeben werden soll.*/ int slot);
//Fragt Eigenschaftswerte des Szenarios anhand dessen Namen/Sekion in der <emlink>Scenario.txt<emlink/> ab
global func any GetScenarioVal(/* Name des abzufragenden Eintrags*/ string entry, /* Sektion des abzufragenden Eintrags. Wenn nicht angegeben, werden alle Sektionen nach einem Eintrag mit dem entspr. Namen durchsucht.*/ string section, /* Nummer des abzufragenden Wertes, wenn der Eintrag mehrere Werte enthält.*/ int entry_number);
//Liefert die aktuelle Jahreszeit. 0 ist Winter, 50 Sommer.
global func int GetSeason();
//Gibt die mit <funclink>SetSkyAdjust<funclink/> gesetzte Himmelsmodulation zurück. Siehe <funclink>SetSkyAdjust<funclink/> für mehr Informationen.
global func int GetSkyAdjust(/* Wenn ungleich <code>false<code/>, wird die in SetSkyAdjust angegebene Zweitfarbe zurückgegeben.*/ bool back_color);
//Liefert den Namen eines Spielers mit Markup in dessen Spielerfarbe. Wenn die Spielernummer zu keinem gültigen Spieler gehört, wird <code>nil<code/> zurückgegeben. Dadurch kann diese Funktion auch benutzt werden, um zu ermitteln, ob eine Spielernummer gültig ist.
global func string GetTaggedPlayerName(/* Spielernummer des Spieler, dessen Name abgefragt werden soll*/ int player);
//Gibt die indizierte Teamnummer zurück. Die Funktion garantiert für Werte zwischen 0 und GetTeamCount()-1, dass eine gültige Teamnummer zurückgegeben wird (denn durch eliminierte Spieler und Neubeitritte kann es vorkommen, dass "Löcher" unbelegter Teamnummern in der Liste entstehen!). Damit ist es einfacher, eine Schleife zu schreiben, die alle Teamnummern durchgeht.
global func int GetTeamByIndex(/* Index in der Teamliste*/ int index);
//Liefert die Farbe eines Teams.
global func int GetTeamColor(/* Teamnummer des Teams, dessen Farbe abgefragt werden soll*/ int team);
//Liefert die Anzahl der Teams, die momentan im Spiel sind.
global func int GetTeamCount();
//Liefert den Namen eines Teams.
global func string GetTeamName(/* Teamnummer des Teams, dessen Name abgefragt werden soll*/ int team);
//Liefert die globale Temperatur. Werte abhängig von Klima und Jahreszeit zwischen +80 und -80.
global func int GetTemperature();
//Gibt die Zeit seit Windowsstart in Millisekunden zurück. Kann zur genauen Zeitmessung verwendet werden.
global func int GetTime();
//Gibt den Typ des übergebenen Werts zurück.
global func int GetType(/* Wert dessen Typ abgefragt werden soll.*/ Value);
//Gibt eine ungenutzte Overlay-ID zurück. Es wird der erste freie Overlay nach base_index zurückgegeben.
global func int GetUnusedOverlayID(/* ID des Overlays hinter dem die Suche beginnen soll.*/ int base_index);
//Gibt einen Objekt- oder Definitionswert zurück.<br><br/>Ein Objektwert berechnet sich folgendermaßen: Zunächst geprüft, ob eine CalcValue-Funktion im Script des Objekttyps vorhanden ist, und gegebenenfalls ausgewertet. Ansonsten wird der Definitionswert (siehe nächster Absatz) verwendet. Unabhängig davon wird der Wert des Objekts immer mit der Fertigstellung (<placeholder-1><placeholder-1/>()/100) multipliziert. Tote Lebewesen (<placeholder-2><placeholder-2/>()&<placeholder-3><placeholder-3/> && !<placeholder-4><placeholder-4/>()) haben immer den Wert 0.<br><br/>Der Definitionswert wird folgendermaßen ermittelt: Ist eine CalcDefValue-Funktion im Script vorhanden, wird diese ausgewertet. Ansonsten wird eine Wertüberladung aus der Scenario.txt verwendet. Ist diese ebenfalls nicht vorhanden, wird der in der DefCore angegebene Wert benutzt.<br><br/>
global func int GetValue(/* Basis, in der gekauft wird. Falls in diesem Objekt ein CalcValue-Aufruf zur Verfügung stellt, wird dieser Parameter an den Aufruf weitergegeben.*/ object base, /* Spieler, für den der Wert gilt. Falls in diesem Objekt ein CalcValue-Aufruf zur Verfügung stellt, wird auch dieser Parameter an den Aufruf weitergegeben.*/ int for_player);
//Liefert eine Koordinate des indizierten Vertex (siehe <emlink>DefCore.txt<emlink/>) des aufrufenden Objekts. Koordinaten in Relation zur Objektmitte.
global func int GetVertex(/* Index des Vertex.*/ int index, /* 
            <table>
              <rowh>
                <col>Wert<col/>
                <col>Bedeutung<col/>
              <rowh/>
              <row>
                <col>VTX_X<col/>
                <col>X-Koordinate des Vertex.<col/>
              <row/>
              <row>
                <col>VTX_Y<col/>
                <col>Y-Koordinate des Vertex.<col/>
              <row/>
              <row>
                <col>VTX_CNAT<col/>
                <col><emlink>CNAT-Wert<emlink/> des Vertex.<col/>
              <row/>
              <row>
                <col>VTX_Friction<col/>
                <col>Reibung des Vertex.<col/>
              <row/>
            <table/>
          */ int data);
//Liefert die Anzahl der Vertices des aufrufenden Objekts.
global func int GetVertexNum();
//Liefert das Vermögen von owner.
global func int GetWealth(/* Spielernummer*/ int owner);
//Liefert die Windstärke und Richtung an der Position X, Y. Wird die Funktion aus einem Objekt heraus aufgerufen, so ist die Position relativ zur Objektposition. Wenn global is <code>true<code/>, wird der globale Wind zurückgegeben.
global func int GetWind(/* X-Position*/ int x, /* Y-Position*/ int y, /* Ob der globale Wind abgefragt werden soll.*/ bool global);
//Liefert die X-Position des aufrufenden Objekts.
global func int GetX();
//Liefert die Geschwindigkeit in X-Richtung des aufrufenden Objekts.
global func int GetXDir(/* Genauigkeit mit der die Geschwindigkeit zurückgegeben werden soll (Standardwert: 10)*/ int precision);
//Liefert die Y-Position des aufrufenden Objekts.
global func int GetY();
//Liefert die Geschwindigkeit in Y-Richtung des aufrufenden Objekts.
global func int GetYDir(/* Genauigkeit mit der die Geschwindigkeit zurückgegeben werden soll (Standardwert: 10)*/ int precision);
//Entfernt sämtlichen Inhalt von *obj, und gibt diesen dem aufrufenden Objekt.
global func bool GrabContents(/* Objekt dessen Inhalt gestohlen werden soll.*/ object obj);
//Überträgt die Infosektion von einem anderen Objekt zu dem aufrufenden Objekt. Die Infosektion enthält Namen, Rang, permantente Physicals, usw. Mit diesem Befehl lassen sich beispielsweise Wiederbelebungen realisieren, indem einfach beim Tod eines Clonks ein neuer erstellt und die Infosektion übertragen wird.
global func bool GrabObjectInfo(/* Objekt (Clonk), von dem die Infosektion genommen werden soll.*/ object from);
//Prüft, ob zwei Spieler verfeindet sind. Dazu reicht es, wenn nur einer von beiden mit dem anderen Spieler verfeindet ist.
global func bool Hostile(/* Erster Spieler*/ int player1, /* Zweiter Spieler*/ int player2, /* Wenn <code>true<code/>, wird nur geprüft, ob player1 mit player2 verfeindet ist und nicht umgekehrt.*/ bool check_one_way);
//Setzt einen 32Bit-Farbwert aus den drei Parametern zusammen. 0-255 für alle Parameter.
global func int HSL(/* Farbton der Farbe. 0 ist Rot, 85 ist Grün, 170 Blau und 255 wieder Rot.*/ int byH, /* Sättigung der Farbe. Dies ist der Farbkontrast.*/ int byS, /* Helligkeit der Farbe. Helligkeit gleich null entspräche <funclink>RGB<funclink/>(0,0,0)*/ int byL);
//Wandelt einen 24Bit HSL-Wert in den bekannten 32Bit RGB-Farbwert um.<br><br/> Der 24Bit HSL-Wert kann mit <funclink>RGB<funclink/>(Hue,Saturation,Lightness) erzeugt werden.<br><br/>
global func int HSL2RGB(/* 24Bit HSL-Wert*/ int Val);
//Setzt einen 32Bit-Farbwert aus den drei Parametern und einem Durchsichtigkeitswert zusammen. 0-255 für alle Parameter.
global func int HSLa(/* Farbton der Farbe. 0 ist Rot, 85 ist Grün, 170 Blau und 255 wieder Rot.*/ int byH, /* Sättigung der Farbe. Dies ist der Farbkontrast.*/ int byS, /* Helligkeit der Farbe. Helligkeit gleich null entspräche <funclink>RGB<funclink/>(0,0,0)*/ int byL, /* Deckkraft der Farbe.*/ int byA);
//Zündet das aufrufende Objekt an. In dem jeweiligen Objekt wird ggf. Incineration() aufgerufen
global func bool Incinerate();
//Ruft die überladene Funktion auf. Funktionen überladen sich, wenn sie beide den gleichen Namen haben.
global func any inherited();
//Gibt <code>true<code/> zurück, wenn sich das aufrufende Objekt in einer Flüssigkeit befindet.
global func bool InLiquid();
//Inserts a material pixel at the given position and given speed.
global func bool InsertMaterial(/* Einzufügendes Material (siehe <funclink>Material<funclink/>())*/ int material_index, /* X-Einfügeposition/-offset*/ int x, /* Y-Einfügeposition/-offset*/ int y, /* X-Geschwindigkeit des eingefügten Mateiralpixels*/ int xdir, /* Y-Geschwindigkeit des eingefügten Mateiralpixels*/ int ydir, /* If a writeable proplist is passed, members x and y are filled with the actual insertion position.*/ proplist out_insertpos);
//Gibt <code>true<code/> zurück, wenn value >= lower_bound und value <= upper_bound ist.
global func bool Inside(/* Eingabewert*/ int value, /* Untergrenze für den Wert*/ int lower_bound, /* Obergrenze für den Wert*/ int upper_bound);
//Prüft, ob das aktuelle Spiel ein Netzwerkspiel ist.
global func bool IsNetwork();
//Veranlasst das Objekt dazu, zu springen. Dabei gelten sämtliche Beschränkungen, die auch bei Ansteuerung über die Tastatur gelten: Das Objekt kann nur springen, wenn es gerade steht (seine Action die Procedure "WALK" hat).<br><br/> Im Wasser wird die Action "Dive" aktiviert.<br><br/> Die Funktion gibt zurück, ob die Aktion erfolgreich durchgeführt wurde.
global func bool Jump();
//Tötet das aufrufende Objekt. Nur Lebewesen.
global func bool Kill(/* Wenn gesetzt, wird das Objekt auch dann getötet, wenn ein Effekt das zu unterbrechen versucht.*/ bool forced);
//Gibt die Höhe der Landschaft in Pixel zurück.
global func int LandscapeHeight();
//Gibt die Breite der Landschaft in Pixel zurück.
global func int LandscapeWidth();
//Erzeugt einen Erdbeben an angegebener Stelle. Koordinaten auch bei lokalem Aufruf global
global func bool LaunchEarthquake(/* X-Position*/ int x, /* Y-Position*/ int y);
//Erzeugt einen Blitz. Dieser bewegt sich von der Position (x, y) mit der angegebenen Geschwindigkeit fort. Dabei geben xrange/yrange an, wie sehr der Blitz von diesem vorgegegebenen Weg abweichen kann (mit xrange = yrange = 0 würde der Blitz schnurgerade verlaufen). xrange/yrange sind sozusagen ein Maß für die "Zackigkeit" eines Blitzes.<br><br/> Die Position muss auch bei lokalem Aufruf in globalen Koordinaten angegeben werden.
global func bool LaunchLightning(/* X-Position*/ int x, /* Y-Position*/ int y, /* horizontale mittlere Geschwindigkeit des Blitzes*/ int xspeed, /* maximale Abweichung von xspeed*/ int xrange, /* vertikale mittlere Geschwindigkeit des Blitzes*/ int yspeed, /* maximale Abweichung von yspeed*/ int yrange, /* Wenn gesetzt, bewirkt dieser Blitz ein Aufflackern des Bildschirms bei allen Spielern.*/ bool do_gamma);
//Erzeugt einen Vulkan an angegebener Position
global func bool LaunchVolcano(/* X-Position*/ int x, /* Y-Zielposition. Default: am unteren Ende der Landschaft*/ int y, /* Stärke. Default: relativ zur Höhe der Landschaft*/ int strength, /* Name des Materials. Default ist "Lava"*/ string material_name);
//Gibt einen Text im Messageboard am unteren Bildschirmrand aus. Die Parameter können über den C-Formatierungsstil in den Text eingebunden werden. Siehe dazu auch <funclink>Format<funclink/>.
global func bool Log(/* Auszugebender Text*/ string message);
//Fügt das aufrufende Objekt (z.B. einen Clonk) der Crew eines Spielers hinzu. Das Objekt muss die CrewMember-Eigenschaft in der DefCore gesetzt haben.<br><br/> Gibt <code>true<code/> zurück, wenn das Objekt erfolgreich der Crew hinzugefügt wurde.
global func bool MakeCrewMember(/* Spieler, dessen Crew das Objekt hinzugefügt werden soll.*/ int player);
//Gibt den Index eines Materials anhand seines Namens zurück. Dieser Index wird in den meisten materialbezogenen Funktionen verwendet.
global func int Material(/* Name des Materials*/ string material_name);
//Gibt den (internen, englischen) Namen eines Materials zurück.
global func string MaterialName(/* Index des Materials, dessen Name ermittelt wird*/ int material_index);
//Gibt den größeren der beiden Werte zurück
global func int Max(/* erster Wert*/ int value1, /* zweiter Wert*/ int value2);
//Zeigt eine Nachricht an. Diese kann nach dem C-Formatierungsstil formatiert werden (siehe <funclink>Format<funclink/>)
global func bool Message(/* Nachricht, die angezeigt werden soll.*/ string message);
//Gibt den kleineren der beiden Werte zurück
global func int Min(/* erster Wert*/ int value1, /* zweiter Wert*/ int value2);
//Spielt ein Musikstück ab. Die entsprechende Datei muss in einer der aktiven Musikdateien vorhanden sein. Sind im ausgewählten Szenario Musikdateien vorhanden, gilt die Szenariodatei als aktive Musikdatei, andernfalls wird die globale Musikdatei Music.ocg genutzt.
global func int Music(/* Dateiame des Musikstückes. Die Endung muss mit angegeben werden. Wird der Parameter weggelassen, so wird die Musikwiedergabe unterbrochen.*/ string song_name, /* Wenn 1, wird das angegebene Musikstück andauernd abgespielt.*/ bool loop);
//Setzt die Lautstärke, mit der die Hintergrundmusik abgespielt wird (siehe <funclink>Music<funclink/>).
global func int MusicLevel(/* Gewünschte Lautstärke (0-100).*/ int level);
//Wandelt eine Objektnummer in einen Objektpointer um.
global func object Object(/* Eindeutige Objektnummer.*/ int object_number);
//Gibt die Anzahl der Objekte zurück, die das angegebenen Suchkriterien erfüllen. Die Suchkriterien werden mittels speziellen Kriteriums-Funktionen der Form "Find_*" angegeben.
global func int ObjectCount(/* Suchkriterium in Form einer Find_*-Funktion*/ array Criteria);
//Liefert die Distanz zwischen zwei Objekten. Ist obj <code>nil<code/>, Wird die Distanz zwischen dem aufrufenden Objekt und obj2 gemessen.
global func int ObjectDistance(/* Zweites Objekt.*/ object obj2, /* Erstes Objekt. <code>nil<code/> bei lokalem Aufruf.*/ object obj);
//Bestimmt die Nummer des aufrufenden Objekts. Diese Nummer ist eindeutig und kann mittels der Funktion <funclink>Object<funclink/> in einen Objektpointer zurückverwandelt werden.
global func int ObjectNumber();
//Gibt zurück, ob das aufrufende Objekt brennt.
global func bool OnFire();
//Gibt einen der an die Funktion übergebenen Parameter zurück.
global func any Par(/* 0-9: Index des abzufragenden Parameters*/ int index);
//Gibt zurück, ob der Weg zwischen den beiden angegebenen Punkten in der Landschaft frei ist, d.h., ob sich keine festen Materialien auf der Verbindungslinie zwischen den Punkten befinden.
global func bool PathFree(/* X-Position des Anfangspunktes*/ int x1, /* Y-Position des Anfangspunktes*/ int y1, /* X-Position des Endpunktes*/ int x2, /* Y-Position des Endpunktes*/ int y2);
//Erzeugt ein Lebewesen vom angegebenen Typ in der Landschaft. Die Startposition bestimmt sich dabei aus dem Wert Placement im <emlink>DefCore<emlink/> des Lebewesens. Rückgabewert ist ein Zeiger auf das neu erzeugte Objekt.
global func object PlaceAnimal(/* ID des zu erstellenden Tieres.*/ id animal_id);
//Erzeugt amount viele Objekte im angegebenen Zielrechteck (optional) im angegebenen Material. Gibt die Anzahl der Iterationen zurück, oder -1 wenn die Erzeugung fehlschlägt.
global func int PlaceObjects(/* ID des zu platzierenden Objekts*/ id definition, /* Menge der zu erzeugenden Objekte*/ int amount, /* 
            Material in which object are to be created. This can be a material number or a string as follows: 
            <table>
              <rowh>
                <col>material_index<col/>
                <col>Erzeugung in<col/>
              <rowh/>
              <row>
                <col>"GBackSolid"<col/>
                <col>Objekte werden in festem Material erzeugt. Siehe auch <funclink>GBackSolid<funclink/>()<col/>
              <row/>
              <row>
                <col>"GBackSemiSolid"<col/>
                <col>Objekte werden in festem oder flüssigem Material erzeugt. Siehe auch <funclink>GBackSemiSolid<funclink/>()<col/>
              <row/>
              <row>
                <col>"GBackLiquid"<col/>
                <col>Objekte werden in flüssigem Material erzeugt. Siehe auch <funclink>GBackLiquid<funclink/>()<col/>
              <row/>
              <row>
                <col>"GBackSky"<col/>
                <col>Objekte werden im freien Himmel erzeugt. Siehe auch <funclink>GBackSky<funclink/>()<col/>
              <row/>
            <table/>

          */ string material_name, /* Linke Kante der Position. Bei lokalem Aufruf Offset zum aufrufenden Objekt.*/ int x, /* Obere Kante der Position. Bei lokalem Aufruf Offset zum aufrufenden Objekt.*/ int y, /* Platzierrechteck Breite. Wenn nicht angegeben wird das Ende der Landschaft angenommen*/ int width, /* Platzierrechteck Höhe. Wenn nicht angegeben wird das Ende der Landschaft angenommen*/ int height, /* Wenn <code>true<code/>, werden alle Objekte oberhalb des angegeben Materials erzeugt. (Ohne Berücksichtigung des Zielrechtecks)*/ bool on_surface, /* Wenn <code>true<code/>, wird nicht sichergestellt dass des Objekt fest in der Erde ist. Dies ist z.B.: nötig wenn man Objekte im Flüssigkeiten erstellen will.*/ bool no_stuck);
//Platziert Vegetation im angegebenen Zielrechteck. Bei lokalen Aufrufen gelten die Koordinaten als Offset zur Mitte des aufrufenden Objekts. Rückgabewert ist ein Zeiger auf das neu erzeugte Objekt.
global func object PlaceVegetation(/* ID des zu erstellenden Objekts.*/ id id, /* Obere linke Ecke des Zielrechtecks, X-Koordinate*/ int x, /* Obere linke Ecke des Zielrechtecks, Y-Koordinate*/ int y, /* Breite des Zielrechtecks*/ int width, /* Höhe des Zielrechtecks*/ int height, /* Wachstumsphase des Zielobjekts. -1 platziert Vegetation in zufälligem Wachstumsstadium, ansonsten gilt der Wertebereich 1-100000 (1-100%)*/ int growth);
//Spielt eine neue neue Animation ab. Der Rückgabewert der Funktion ist die Animationsnummer des eingefügten Animationsknotens, mit der die Animation später manipuliert oder wieder entfernt werden kann. Falls im angegebenen Slot bereits Animationen vorhanden sind, so wird auch ein Kombinationsknoten erstellt. Dieser erhält die zurückgegebene Nummer plus 1.
global func int PlayAnimation(/* Name der abzuspielenden Animation.*/ string animation, /* Slot im Animation Stack in den die Animation eingefügt werden soll. Siehe <emlink>Animationen<emlink/>.*/ int slot, /* Bestimmt, wie die aktuelle Position der Animation berechnet wird. Diese wird mittels Animationsfunktionen der Form "Anim_" angegeben.*/ array position, /* Bestimmt, wie die aktuelle Gewichtung der Animation berechnet wird, falls die Animation mit einer anderen Animation im gegebenen Slot kombiniert wird. Diese wird mittels Animationsfunktionen der Form "Anim_" angegeben.*/ array weight, /* Falls die Animation mit einer anderen Animation kombiniert wird, dann gibt dies den Knoten an, mit dem die neue Animation kombiniert wird. Falls nicht angegeben oder <code>nil<code/> wird die Animation mit der obersten Animation des Slots verknüpft wie sie von <funclink>GetRootAnimation<funclink/> zurückgeliefert wird.*/ int sibling);
//Gibt eine Nachricht nur im Viewport eines Spielers aus. Die Nachrichtenformatierung erfolgt analog zu <funclink>Message<funclink/>.
global func bool PlayerMessage(/* Nummer des Spielers, bei dem die Nachricht ausgegeben wird*/ int player, /* Nachricht, die ausgegeben wird*/ string message);
//Schlägt obj.
global func bool Punch(/* Das Opfer.*/ object obj, /* Stärke des Schlages (abgezogene Energiemenge).*/ int strength);
//Beschleunigt alle Partikel eines angegebenen Typs in die angegebene Richtung.
global func bool PushParticles(/* Name der Partikeldefinition, dessen Instanzen beschleunigt werden sollen. Wenn nicht angegeben werden alle Partikeltypen beschleunigt.*/ string name, /* Horizontalbeschleunigung*/ int xacc, /* Vertikalbeschleunigung*/ int yacc);
//Gibt eine Zufallszahl zwischen 0 und max-1 zurück. Der zurückgegebene Wert kann jedoch nicht höher als 32767 sein.
global func int Random(/* Höchstwert*/ int max);
//Liefert einen Zufallswert zwischen value1 und value2. Dabei ist egal, welcher Wert der größere ist.
global func int RandomX(/* Anfang des Bereichs*/ int value1, /* Ende des Bereichs*/ int value2);
//Aktualisiert eine Definition. Dieser Befehl kann im Entwicklermodus in der Konsole eingegeben werden, nachdem die Definition auf der Festplatte verändert wurde. Sie muss zuvor geladen gewesen sein.
global func bool ReloadDef(/* ID der neu zu ladenden Definition*/ id definition);
//Aktualisiert eine Partikeldefinition. Dieser Befehl kann im Entwicklermodus in der Konsole eingegeben werden, nachdem die Definition auf der Festplatte verändert wurde. Sie muss zuvor geladen gewesen sein.
global func bool ReloadParticle(/* Name des neu zu ladenden Partikeltyps.*/ string particle);
//Entfernt alle Objekte die den Suchkriterien entsprechen.
global func int RemoveAll(/* Suchkriterium in Form einer Find_*-Funktion*/ array Criteria);
//Löscht einen Effekt
global func bool RemoveEffect(/* Name des Effektes ohne vorangestelltes Fx. Es können '*' und '?' als Suchmaske verwendet werden.*/ string name, /* Zielobjekt, in dem ein Effekt gelöscht werden sollen. Bei <code>nil<code/> wird die globale Effektliste durchsucht.*/ object target, /* Der Effekt. Statt nach dem Namen zu suchen, kann der Effekt direkt entfernt werden wenn dieser Parameter angegeben ist.*/ proplist effect, /* Wenn ungleich <code>false<code/>, werden keine Stop-Aufrufe durchgeführt.*/ bool no_calls);
//Entfernt das aufrufende Objekt.
global func any RemoveObject(/* Wenn wahr, wird der Inhalt des Objekts vor der Vernichtung ausgeleert. Ansonsten wird er mit vernichtet.*/ bool eject_contents);
//Entfernt einen Vertex vom aufrufenden Objekt.
global func int RemoveVertex(/* Index des Vertex, das entfernt werden soll.*/ int index);
//Setzt eine Gammarampe auf den Normalwert zurück. Dies entspricht <funclink>SetGamma<funclink/>(<funclink>RGB<funclink/>(0,0,0), <funclink>RGB<funclink/>(128,128,128), <funclink>RGB<funclink/>(255,255,255), ramp_index);. Für weitere Informationen siehe <funclink>SetGamma<funclink/>.
global func bool ResetGamma(/* 0-7: Index der Gammarampe, die zurückgesetzt werden soll.*/ int ramp_index);
//Setzt alle Physicals auf den Normalwert zurück. Für weitere Informationen siehe <funclink>SetPhysical<funclink/>.
global func bool ResetPhysical(/* Sollte, wenn angegeben, der Name einer Physical sein, die zuvor mit <funclink>SetPhysical<funclink/> im Modus PHYS_StackTemporary gesetzt wurde. Es wird dann diese Physical auf den alten Wert, den sie vor dem temporären Setzen hatte, zurückgesetzt und die temporäre Änderung vom Stapel entfernt. Ist der Stapel leer - das heißt, wenn für alle <funclink>SetPhysical<funclink/>-Aufrufe mit PHYS_StackTemporary-Parameter entsprechende ResetPhysical-Aufrufe mit sPhys-Parameter getätigt wurden, werden die temporären Physicals wieder gelöscht. Ist der Parameter 0 oder nicht angegeben, werden die temporären Physicals immer zurückgesetzt und alle temporären Zwischenwerte vom Stapel gelöscht. Für ein Beispiel zu diesem Parameter siehe <funclink>SetPhysical<funclink/>.*/ string physical);
//Setzt einen 32Bit-Farbwert aus den drei Grundfarben zusammen. 0-255 für alle Parameter.
global func int RGB(/* Rotanteil für die Farbe*/ int byR, /* Grünanteil für die Farbe*/ int byG, /* Blauanteil für die Farbe*/ int byB);
//Wandelt einen 32Bit-Farbwert in die entsprechenden Hue-, Saturation- und Lightness-Werte um wie bereits von Malprogrammen bekannt.<br><br/> Die HSL Werte werden ebenfalls als int zurückgegeben und können mit <funclink>GetRGBaValue<funclink/> oder <funclink>SplitRGBaValue<funclink/> weiter verwendet werden.<br><br/> Alle Werte sind von 0 bis 255 skaliert.
global func int RGB2HSL(/* 32Bit-Farbwert*/ int Val);
//Setzt einen 32Bit-Farbwert aus den drei Grundfarben und einem Durchsichtigkeitswert zusammen. 0-255 für alle Parameter.
global func int RGBa(/* Rotanteil für die Farbe*/ int byR, /* Grünanteil für die Farbe*/ int byG, /* Blauanteil für die Farbe*/ int byB, /* Deckkraft*/ int byA);
//Führt einen bestimmes Script mit Verzögerung aus.
global func bool Schedule(/* Objekt, in dem das Script ausgeführt werden soll. <code>nil<code/> für ohne Objektkontext.*/ object obj, /* Auszuführendes Script*/ string script, /* Zeit, bis die Funktion zum ersten Mal aufgerufen werden soll. Wenn repeat > 1, ist es außerdem der Zeitabstand zwischen erneuten Aufrufen.*/ int delay, /* Anzahl der Aufrufe. Wenn 0 oder nicht angegeben wird die Funktion genau ein mal aufgerufen.*/ int repeat);
//Ruft eine Funktion nach einer angegebenen Verzögerung auf.
global func bool ScheduleCall(/* Objekt, in dem die Funktion aufgerufen werden soll. <code>nil<code/> für ohne Objektkontext.*/ object obj, /* Name der Funktion, die aufgerufen werden soll.*/ string function, /* Zeit, bis die Funktion zum ersten Mal aufgerufen werden soll. Wenn repeat > 1, ist es außerdem der Zeitabstand zwischen erneuten Aufrufen.*/ int delay, /* Anzahl der Aufrufe. Wenn 0 oder nicht angegeben wird die Funktion genau ein mal aufgerufen.*/ int repeat);
//Wandelt eine Objektdefinitions-ID in eine Zahl um, die als Spaltenidentifikator für <funclink>SetScoreboardData<funclink/> verwendet werden kann. Diese Funktion ist dann interessant, wenn ein Objekt auf das Scoreboard zugreifen will, aber dabei sicher stellen muss, dass es nicht dieselbe ID wie ein anderes Objekt verwendet.
global func int ScoreboardCol(/* C4ID, die in einen Scoreboard-Spaltenindex umgewandelt werden soll. Für Scoreboards auf Objektbasis sollte hier die ID der Objektdefinition genommen werden, die die Scoreboardfunktionen bereit stellt.*/ id definition);
//Rotiert den Inhalt des aufrufenden Objekts. Dabei wird immer genau ein Objekt weiter gescrollt (im Gegensatz zu <funclink>ShiftContents<funclink/>). Es wird außerdem kein ControlContents aufgerufen. <br><br/> Zurückgegeben wird ein Pointer auf das Objekt, das sich nach der Rotation am Anfang der Inhaltsliste befindet.
global func object ScrollContents();
//Setzt die Auswahl in einem Menü.
global func bool SelectMenuItem(/* Nummer des MenuItems, das selektiert werden soll. Der erste Eintrag hat die Nummer 0.*/ int number);
//Verkauft das aufrufende Objekt mitsamt Inhalt.
global func any Sell(/* Nummer des Spielers, an den verkauft wird*/ int player);
//Setzt die Aktivität des aufrufenden Objekts. Siehe auch <emlink>ActMap<emlink/>.
global func bool SetAction(/* Neue Aktivität. "ActIdle" oder "Idle" löscht die Aktivität.*/ string action, /* Erstes Zielobjekt für die Aktivität*/ object target1, /* Zweites Zielobjekt für die Aktivität*/ object target2, /* Wenn <code>true<code/> wir die Aktion selbst dann geändert wenn in der momentanten Aktion NoOtherAction=1 gesetzt ist.*/ bool force);
//Setzt den Zusatzparameter für die aktuell ausgeführte Aktivitäts-Prozedur. Die Auswirkung dieses Parameters hängt von der gesetzten Prozedur ab. Siehe dazu auch <emlink>ActMap-Prozeduren<emlink/>.
global func bool SetActionData(/* Zusatzparameter für die Aktivität.*/ data);
//Setzt die aktuellen Aktivitätszielobjekte des aufrufenden Objekts. Die Auswirkung der Zielobjekte richtet sich nach der <emlink>Prozedur<emlink/> der aktuell gesetzten Aktivität.
global func any SetActionTargets(/* Erstes Zielobjekt*/ object target1, /* Zweites Zielobjekt*/ object target2);
//Legt fest, ob ein Objekt lebt.
global func int SetAlive(/* false = Tot; ansonsten lebendig*/ bool alive);
//Setzt die Position der angegebenen Animation neu. Rückgabewert <code>true<code/> falls der neue AVP gesetzt wurde oder <code>false<code/> wenn es keine Animation mit der angegebenen Nummer gibt oder es sich bei ihr um einen Kombinationsknoten handelt.
global func bool SetAnimationPosition(/* Animationsnummer der Animation deren Position gesetzt werden soll.*/ int animation_number, /* Bestimmt, wie die aktuelle Position der Animation berechnet wird. Diese wird mittels Animationsfunktionen der Form "Anim_" angegeben.*/ array position);
//Setzt die Gewichtung der angegebenen Animation neu. Rückgabewert <code>true<code/> falls der neue AVP gesetzt wurde oder <code>false<code/> wenn es keine Animation mit der angegebenen Nummer gibt oder es sich bei ihr um einen Animationsknoten handelt.
global func bool SetAnimationWeight(/* Animationsnummer der Animation deren Position gesetzt werden soll.*/ int animation_number, /* Bestimmt, wie die aktuelle Gewichtung der Animation berechnet wird, falls die Animation mit einer anderen Animation im gegebenen Slot kombiniert wird. Diese wird mittels Animationsfunktionen der Form "Anim_" angegeben.*/ array weight);
//Wurde zuvor mit <placeholder-1><placeholder-1/> ein Mesh an einem anderen befestigt, so kann mit dieser Funktion einer oder beide der Bones geändert werden mit denen sie aneinander hängen. Um nur einen Bone zu ändern kann für den anderen Parameter <code>nil<code/> angegeben werden.
global func bool SetAttachBones(/* Nummer des angehängten Meshes. Der Rückgabewert von <funclink>AttachMesh<funclink/> bildet solch eine Nummer.*/ int attach_number, /* Bone am aufrufenden Objekt an den das Mesh angehängt werden soll.*/ string parent_bone, /* Bone des anzuhängenden Meshes mit dem es befestigt werden soll.*/ string child_bone);
//Wurde zuvor mit <funclink>AttachMesh<funclink/> ein Mesh an einem anderen befestigt, so kann mit dieser Funktion die Transformation des angehängten Meshes geändert werden.
global func bool SetAttachTransform(/* Nummer des angehängten Meshes dessen Transformation geändert werden soll. Der Rückgabewert von <funclink>AttachMesh<funclink/> bildet solch eine Nummer.*/ int attach_number, /* Neue Transformation im Koordinatensystem des angehängten Meshes, die auf selbiges angewandt wird. Das Array sollte 12 Integer-Einträge haben die eine 3x4-Matrix beschreiben wobei jeder Wert in Promille (1000 = 100%) angegeben ist. Die Matrizen können auch mit <funclink>Trans_Identity<funclink/>, <funclink>Trans_Translate<funclink/>, <funclink>Trans_Rotate<funclink/> und <funclink>Trans_Scale<funclink/> erzeugt und mit <funclink>Trans_Mul<funclink/> kombiniert werden.*/ array transformation);
//Gibt die neue Bitmaske mit dem an bit_number durch bit ersetzten Bit zurück.
global func int SetBit(/* Alter Wert der Bitmaske*/ int old_value, /* Das zu verändernde Bit*/ int bit_number, /* Der neue Wert des Bits*/ bool bit);
//Setzt Zusatzparameter für eine aktuell ausgeführte BRIDGE-Prozedur des aufrufenden Objekts.
global func bool SetBridgeActionData(/* Länge der Brücke.*/ int bridge_length, /* Ob sich der Clonk mit der Brücke mitbewegen soll.*/ bool move_clonk, /* Sollte <code>true<code/> sein, wenn der Clonk keine Brücke, sondern eine Wand (d.h. über seinem Kopf) baut.*/ bool build_wall, /* Materialnummer des Materials aus dem die Brücke bestehen soll.*/ int bridge_material);
//Ändert die Kategorie des aufrufenden Objekts.
global func any SetCategory(/* Objektkategorie. Sollte ein gültiger C4D_x-Wert sein.*/ int category);
//Setzt das Klima (Durchschnittstemperatur).
global func any SetClimate(/* Temperatur zwischen -50 und 50.*/ int temperature);
//Ändert die Farbmodulation des aufrufenden Objekts. Diese ist ein Farbwert, der multiplikativ aufgerechnet wird. Bei <funclink>RGB<funclink/>(255,0,0) würden also nur die Rotanteile der Grafik gezeichnet werden. <funclink>RGBa<funclink/>(255,255,255,128) würde die Grafik halbtransparent machen.
global func bool SetClrModulation(/* Neue Farbe, mit der moduliert wird.*/ int color, /* Wenn angegeben, wird stattdessen die Farbmodulation dieses Grafikoverlays gesetzt. Das Overlay muss vorher mit <funclink>SetGraphics<funclink/> erstellt worden sein.*/ int overlay_id);
//Setzt die ColorByOwner-Färbung des aufrufenden Objekts. Dieser Aufruf entspricht dem Setzen eines neuen Besitzers mit <funclink>SetOwner<funclink/> bei einem Spieler mit der Spielerfarbe color.
global func any SetColor(/* Neue Farbe für ColorByOwner-Flächen*/ int color);
//Setzt die Befehlsrichtung des aufrufenden Objekts (siehe <funclink>GetComDir<funclink/>)
global func int SetComDir(/* Befehlsrichtung. Muss <funclink>COMD_None<funclink/>, <funclink>COMD_Stop<funclink/>, <funclink>COMD_Down<funclink/>, <funclink>COMD_DownLeft<funclink/>, <funclink>COMD_DownRight<funclink/>, <funclink>COMD_Left<funclink/>, <funclink>COMD_Right<funclink/>, <funclink>COMD_Up<funclink/>, <funclink>COMD_UpLeft<funclink/> oder <funclink>COMD_UpRight<funclink/> sein.*/ int com_dir);
//Gibt dem aufrufenden Objekt ein Kommando, welches dieses selbstständig (ggf. durch automatische Wegfindung) auszuführen versucht.
global func bool SetCommand(/* Kommandoname (als String). Siehe untere Tabelle*/ string command, /* Zielobjekt für Aktion*/ object target, /* X-Zielkoordinate*/ int x, /* Y-Zielkoordinate*/ int y, /* zweites Zielobjekt*/ object target2, /* zusätzliche Daten zur Aktion*/ Data, /* Anzahl der Wiederholungen (wenn das Kommando fehlschlägt), bis das Kommando abgebrochen wird.*/ int retries);
//Setzt die Anzahl einer Komponente des aufrufenden Objekts.
global func bool SetComponent(/* Hinzuzufügende Komponente*/ id component, /* Zu setzende Anzahl der Komponenten mit der ID component*/ int count);
//Setzt die Fertigstellung des aufrufenden Objekts auf den angegebenen Wert.
global func bool SetCon(/* Fertigstellung/Wachstum in Prozent*/ int con);
//Legt fest, welche Dichte ein Material haben muss, damit das Objekt mit diesem kollidiert. Standardmäßig liegt dieser Wert bei 50 (dichtes Material).
global func bool SetContactDensity(/* Dichte des Materials, mit dem das Objekt kollidieren soll.*/ int density);
//Ändert den steuernden Spieler des aufrufenden Objekts.
global func bool SetController(/* Spielernummer des neuen steuernden Spielers. <code>NO_OWNER<code/> für keinen Spieler.*/ int player);
//Aktiviert oder deaktiviert Mannschaftsmitglieder. Deaktivierte Mannschaftsmitglieder können nicht mehr vom Spieler angewählt werden. So kann es auch passieren, dass ein Spieler zwar 0 Mannschaftsmitglieder zur Auswahl hat, aber trotzdem nicht eliminiert ist. Nur für Objekte, die auch wirklich zu einer Mannschaft gehören. Deaktivierte Mannschaftsmitglieder sind automatisch nicht mehr ausgewählt.
global func any SetCrewEnabled(/* Gibt an, ob das Mannschaftsmitglied aktiviert oder deaktiviert werden soll.*/ bool enabled);
//Mithilfe dieses Befehls können beliebige, scriptdefinierte Werte unter einem gegebenen Namen im Clonk in der Spielerdatei gespeichert werden. Auf diese Weise kann man Daten über einen Clonk in einer Spielerdatei über Szenariogrenzen hinweg erhalten (z.B. für RPGs) Zurückgegeben wird (wenn erfolgreich) der gesetzte Wert.
global func any SetCrewExtraData(/* Name der zugeordneten Daten.*/ string data_name, /* Daten, die gesetzt werden sollen.*/ Data);
/*
Adds or removes an object (usually a clonk) to or from the crew of a player. The object must have the CrewMember property set in the DefCore.
    This does not add the object to the permanent crew of the player, use <funclink>MakeCrewMember<funclink/> for that.
*/
global func bool SetCrewStatus(/* Spielernummer des Spielers, dessen Crew verändert werden soll.*/ int player, /* <code>true<code/> wenn der Clonk der Crew hinzugefügt und <code>false<code/> wenn er aus dieser entfernt werden soll.*/ bool into_crew);
//Setzt die Auswahlmarkierung eines Spielers auf ein Zielobjekt und aktiviert dieses für die Steuerung. Gibt <code>false<code/> zurück falls das Zielobjekt momentan durch <funclink>SetCrewEnabled<funclink/> deaktiviert ist.
global func bool SetCursor(/* Spielernummer*/ int player, /* Anzuwählendes Objekt*/ object obj, /* Wenn angegeben und ungleich <code>false<code/>, wird bei der Anwahl kein Auswahlpfeil angezeigt.*/ bool no_select_arrow);
//Setzt die Richtung des aufrufenden Objekts.
global func int SetDir(/* Aktionsrichtung. Vordefinierte Werte: <funclink>DIR_Right<funclink/> / <funclink>DIR_Left<funclink/>*/ int dir);
//Ermöglicht bzw. verhindert das Betreten dieses Gebäudes.
global func any SetEntrance(/* <code>false<code/> = Geschlossen; <code>true<code/> = Offen*/ bool status);
//Setzt die Sicht in Filmwiedergaben auf den angegebenen Spieler.
global func int SetFilmView(/* Nummer des Spielers, dessen Sicht gezeigt werden soll.*/ int for_player);
//Schaltet den Nebel des Krieges für einen Spieler ein oder aus.
global func any SetFoW(/* Wenn <code>true<code/>,, wird der Kriegsnebel aktiviert, bei <code>false<code/>, deaktiviert.*/ bool enabled, /* Nummer des Spielers.*/ int player);
//Setzt die Spielgeschwindigkeit.
global func bool SetGameSpeed(/* Spielgeschwindigkeit in FPS (Frames per Second). Wird der Parameter nicht angegeben oder <code>false<code/> übergeben, so wird die Standard-Spielgeschwindigkeit (38 FPS) gewählt.*/ int game_speed);
//Setzt eine Gammarampe. Mit Gammarampen kann global das Aussehen des gesamten Spieles gesteuert werden, indem jedem Farbkanal eine eigene Tabelle zugewiesen wird, aus der die neue Helligkeit abgelesen wird. Damit kann man zum Beispiel bestimmte Farben speziell hervorheben, alles abdunkeln oder erhellen oder sogar das Bild komplett invertieren.
global func bool SetGamma(/* Veränderung für dunkle Farben. Standard ist <funclink>RGB<funclink/>(0,0,0) für keine Veränderung.*/ int color1, /* Veränderung für mittlere Farben. Standard ist <funclink>RGB<funclink/>(128,128,128) für keine Veränderung.*/ int color2, /* Veränderung für helle Farben. Standard ist <funclink>RGB<funclink/>(255,255,255) für keine Veränderung.*/ int color3, /* 0-7: Index der zu verändernden Rampe. Es stehen acht Gammarampen zur Verfügung, die aufeinander gerechnet werden. So können zum Beispiel Tag/Nacht-Objekte die globale Helligkeit verändern, ohne dabei andere Effekte wie Blitze zu behindern.*/ int ramp_index);
//Ändert die Grafik des aufrufenden Objekts. Diese beeinflusst die Darstellung des betreffenden Objekts überall im Spiel: In der Landschaft, im Menü oder auf Maussteuerungssymbolen.
global func bool SetGraphics(/* Name der neu zu setzenden Grafik. Bei <code>nil<code/> wird die Standardgrafik gesetzt.*/ string gfx_name, /* Definition, von der die Grafik entnommen werden soll. Wenn nicht angegeben, gilt die Definition des Objekts, dessen Grafik geändert wird. Wenn nicht angegeben für overlay!=0, wird das entsprechende Overlay entfernt.*/ id source_definition, /* Index der zu setzenden Overlaygrafik. Muss wenn angegeben größer 0 sein, und fügt dem Objekt eine Grafik mit dem gegebenen Index hinzu, bzw. ändert sie wenn eine Grafik mit dem gegebenen Overlayindex schon existiert. Overlays mit größerem Index werden stets über denen mit kleinerem Index gezeichnet. Wenn ein Objekt nur eine Overlaygrafik hat, kann die symbolische Konstante GFX_Overlay (=1) verwendet werden.*/ int overlay, /* 
            Only in conjunction with overlay parameter: specifies how the overlay is to be drawn. The following constants are allowed: 
            <table>
              <rowh>
                <col>Konstante<col/>
                <col>Wert<col/>
                <col>Effekt<col/>
              <rowh/>
              <row>
                <col>GFXOV_MODE_None<col/>
                <col>0<col/>
                <col>Ungültig: Nicht benutzen<col/>
              <row/>
              <row>
                <col>GFXOV_MODE_Base<col/>
                <col>1<col/>
                <col>Die Basisgrafik der angegebenen Definition, das heißt das Zielrechteck (0,0,Width,Height,OffsetX,OffsetY), wird an der Objektposition über die Grafik gelegt.<col/>
              <row/>
              <row>
                <col>GFXOV_MODE_Action<col/>
                <col>2<col/>
                <col>Die Aktivität der angegebenen Objektdefinition.<col/>
              <row/>
              <row>
                <col>GFXOV_MODE_Picture<col/>
                <col>3<col/>
                <col>Hat nur Auswirkung, wenn das Objekt im Inventar eines Clonks oder in einem Menü (z.B. Aktivieren in Gebäuden) auftaucht: Das Picture-Rechteck der angegebenen Definition wird über das Repräsentativbild des Objekts gezeichnet. Hiermit können zum Beispiel Zauberer auf Steine oder Zaubersymbole auf Schriftrollen gedruckt werden.<col/>
              <row/>
              <row>
                <col>GFXOV_MODE_IngamePicture<col/>
                <col>4<col/>
                <col>Legt die Picture-Grafik der Quelldefinition über das Shape des Zielobjektes.<col/>
              <row/>
              <row>
                <col>GFXOV_MODE_Object<col/>
                <col>5<col/>
                <col>Legt die aktuelle Objektgrafik inklusive aller Overlays von pOverlayObject über das Objekt. Achtung: Ein Objekt darf sich nicht rekursiv über sich selbst als Overlay legen.<col/>
              <row/>
              <row>
                <col>GFXOV_MODE_ExtraGraphics<col/>
                <col>6<col/>
                <col>Benutzt die angegebene Grafik als Quellgrafik, um das Objekt erneut zu zeichnen. Die Quellkoordinaten sind die gleichen wie die, die auch beim Zeichnen von obj verwendet wurden.<col/>
              <row/>
            <table/>

          */ int overlay_mode, /* Nur für overlay_mode==GFXOV_MODE_Action: Aktivität in der Definition source_definition, dessen Grafik über das Zielobjekt gelegt werden soll. Diese Aktivität muss in der <emlink>ActMap<emlink/> der Quelldefinition definiert sein. Achtung: Die Länge dieser Animation sollte 1 sein; bewegte Animtionen sind noch nicht möglich.*/ string action, /* Blitmodus der überlegten Grafik (z.B. additiv). Siehe <funclink>SetObjectBlitMode<funclink/>*/ int dwBlitMode, /* Nur für overlay_mode==GFXOV_MODE_Object: Objekt, dessen Grafik über das Zielobjekt gelegt werden soll.*/ object overlay_object);
//
global func any SetGravity(/* */ int gravity);
//Setzt das Bündnisverhältnis zwischen zwei Spielern einseitig.
global func bool SetHostility(/* Der Spieler, dessen Bündnisverhältnis gesetzt wird*/ int player1, /* Der Spieler, zu dem das Bündnisverhältnis gesetzt wird*/ int player2, /* Wenn <code>true<code/> wird verfeindet. Ansonsten verbündet.*/ bool hostile, /* Wenn ungleich <code>false<code/>, erscheint keine Verfeindungsnachricht im Messageboard. Im ersten Frame des Spieles wird auch ohne diesen Parameter nie eine Nachricht ausgegeben.*/ bool silent, /* Wenn ungleich <code>false<code/>, werden die Callbacks RejectHostilityChange und OnHostilityChange nicht ausgeführt.*/ bool no_calls);
//Setzt den Mörder des aufrufenden Objekts.
global func bool SetKiller(/* Spielernummer des neuen Besitzers. <code>NO_OWNER<code/> für keinen Besitzer.*/ int new_killer);
//Verändert die Länge eines Arrays auf den angegebenen Wert. Überzählige Elemente werden dabei gegebenenfalls gelöscht.
global func int SetLength(/* Array, dessen Länge verändert werden soll*/ array resize, /* Neue Länge des Feldes*/ int size);
//Ändert die Eigenmasse des aufrufenden Objekts. Die Eigenmasse entspricht dem in der <emlink>DefCore.txt<emlink/> angegebenen Wert unter [DefCore], Mass. Die tatsächliche Objektmasse ergibt sich durch Hinzurechnen der Masse aller enthaltenen Objekte.
global func any SetMass(/* Neue Eigenmasse*/ int mass);
//Setzt die Materialmodulation. Die Materialfarben werden mit der angegebenen Farbe so verrechnet wie auch ColorByOwner-Grafiken.
global func bool SetMatAdjust(/* Primäre Farbmodulation*/ int colorMod);
//Ändert die Maximalzahl der Spieler, die an der Runde teilnehmen können. Dieser Wert wirkt sich nur auf Neubeitritte aus; es werden keine vorhandenen Spieler eliminiert, um das Limit zu erfüllen.
global func bool SetMaxPlayer(/* Neue, maximale Spielerzahl*/ int max);
//Ändert die Größe eines Objektmenüs, so dass die vorgegebene Anzahl an Menüeinträgen in Breite und Höhe hineinpassen.
global func bool SetMenuSize(/* 0-50: Anzahl der Menüeinträge, die das Menü in der Breite anzeigen können soll*/ int coloumns, /* 0-50: Anzahl der Menüeinträge, die das Menü in der Höhe anzeigen können soll*/ int rows);
//Ändert das Material des Meshes des aufrufenden Objekts zur Laufzeit.
global func bool SetMeshMaterial(/* Name des zu setzenden Materials. Es muss beim Start der Engine bereits geladen sein, d.h. in einer *.material-Datei definiert worden sein die sich in einem geladenen Objekt befindet.*/ string material, /* Besteht das Mesh aus mehreren SubMeshes, so kann durch diesen Parameter angegeben werden das Material welches SubMeshes geändert werden soll.*/ int submesh);
//Ändert für eine Runde den Namen eines Objekts oder einer Definition.
global func bool SetName(/* Neuer Name. Wenn <code>nil<code/>, wird der Name des Objekts auf den Namen seiner Definition beziehungsweise den Namen in der Spielerdatei zurückgesetzt.*/ string name, /* Nur für Crewobjekte: Wenn wahr, wird der Name permanent in der Infosektion des Spielers geändert. Namen dürfen jeweils nur einmal pro Spielerdatei vorkommen.*/ bool set_permanent, /* Steuert das Verhalten, falls ein Clonk mit dem angegebenen Namen schon in der Stammcrew des Spielers existiert: Wenn unwahr, schlägt die Funktion in diesem Fall fehl. Wenn wahr, wird ein neuer Name durch Anhängen einer Zahl erzeugt.*/ bool make_valid_if_exists);
//Transformiert die Grafik des aufrufenden Objektes.
global func bool SetObjDrawTransform(/* Breite der Grafik. 1000 ist die Standardbreite, negative Angaben bedeuten eine horizontale Spiegelung der Grafik. Die Grafik wird immer mittig (zentriert) dargestellt.*/ int width, /* Horizontale schräge Streckung der Grafik: 0 bedeutet keine Streckung. 1000 bedeutet eine Verschiebung der horizontalen Kante um 45° nach links (oben nach links, unten nach rechts). Negative Werte bedeuten eine Verschiebung nach rechts.*/ int xskew, /* Horizontale Verschiebung der Grafik. Bei 1000 wird die Grafik einen Pixel nach rechts verschoben, bei negativen Angaben wird die Grafik nach links verschoben. Die Grafik um halbe Pixel zu verschieben, ist auch möglich.*/ int xadjust, /* Vertikale schräge Streckung der Grafik: 0 bedeutet keine Streckung. 1000 bedeutet eine Verschiebung der vertikalen Kante um 45° nach unten (links hoch, rechts runter). Negative Werte bedeuten eine Verschiebung nach oben.*/ int yskew, /* Höhe der Grafik. 1000 ist die Standardhöhe, negative Angaben bedeuten eine vertikale Spiegelung der Grafik. Die Grafik wird immer mittig (zentriert) dargestellt.*/ int height, /* Vertikale Verschiebung der Grafik. Bei 1000 wird die Grafik einen Pixel nach unten verschoben, bei negativen Angaben wird die Grafik nach oben verschoben. Die Grafik um halbe Pixel zu verschieben, ist auch möglich.*/ int yadjust, /* ID des Overlays, dessen Transformation angepasst werden soll. Bei 0 (default) wird die Hauptgrafik transformiert.*/ int overlay_id);
//Ändert den Zeichenmodus für das aufrufende Objekt. Die möglichen Werte entsprechen denen des DefCore-Flags BlitMode (siehe Anmerkung). Die Funktion gibt jeweils den vorher gesetzten Blitmodus zurück.
global func int SetObjectBlitMode(/* Neuer Zeichenmodus (mögliche Werte siehe unten) - bei 0 oder nicht angegeben wird das Objekt auf seinen Definitions-Blitmodus zurückgesetzt. Ansonsten wird Bit 8 (benutzerdefinierter Farbwert) implizit gesetzt.*/ int dwNewBlitMod, /* Wenn angegeben, wird stattdessen der Blitmodus dieses Grafikoverlays gesetzt. Das Overlay muss vorher mit <funclink>SetGraphics<funclink/> erstellt worden sein.*/ int overlay_id);
//Ändert den Besitzer des aufrufenden Objekts.
global func bool SetOwner(/* Spielernummer des neuen Besitzers. <code>NO_OWNER<code/> für keinen Besitzer.*/ int new_owner);
//Setzt die Aktivitätsphase des aufrufenden Objekts.
global func bool SetPhase(/* Neue Aktionsphase.*/ int phase);
//Ändert die physischen Eigenschaften des aufrufenden Objekts. Hiermit können die in der Physical-Sektion der <emlink>DefCore.txt<emlink/> angegebenen Werte temporär oder permanent angepasst werden.
global func bool SetPhysical(/* Name Eigenschaft, die geändert werden soll*/ string physical, /* 0-100000: Neuer Wert für diese Eigenschaft*/ int value, /* 
            Physical attribute change mode:<br><br/>
            <table>
              <rowh>
                <col>Konstante<col/>
                <col>Wert<col/>
                <col>Bedeutung<col/>
              <rowh/>
              <row>
                <col>PHYS_Current<col/>
                <col>0<col/>
                <col>Die Eigenschaften werden im gerade aktiven Modus (temporär oder permanent) des Objektes geändert.<col/>
              <row/>
              <row>
                <col>PHYS_Permanent<col/>
                <col>1<col/>
                <col>The physical attributes are changed in permanent mode. This modifies the info section of the associated crew object, which means that the changes will be written to the player file as well. Only player crew objects have  a permanent info section.<col/>
              <row/>
              <row>
                <col>PHYS_Temporary<col/>
                <col>2<col/>
                <col>Für das Objekt wird eine temporäre Infosektion erzeugt, sofern noch nicht vorhanden, und temporären Modus gesetzt. Änderungen im temporären Modus landen nicht in der Spielerdatei. Um temporäre Physicals wieder zu den Originalen zurückzusetzen, sollte <funclink>ResetPhysical<funclink/> verwendet werden.<col/>
              <row/>
              <row>
                <col>PHYS_StackTemporary<col/>
                <col>3<col/>
                <col>Wie PHYS_Temporary, jedoch wird zusätzlich der vorherige Physical-Wert gesichert und kann einzeln mit einem <funclink>ResetPhysical<funclink/>-Aufruf wiederhergestellt werden.<col/>
              <row/>
            <table/>
<br><br/>
          */ int mode);
//Ändert die Repräsentativgrafik des aufrufenden Objekts auf ein neues Zielrechteck der aktuell benutzten Grafik. Die Repräsentativgrafik wird beispielsweise im Menü oder der Inventarliste des ausgewählten Clonks verwendet. Siehe auch Eintrag Picture in der <emlink>DefCore.txt<emlink/>.
global func any SetPicture(/* X-Position der oberen linken Ecke des neuen Grafikrechtecks*/ int x, /* Y-Position der oberen linken Ecke des neuen Grafikrechtecks*/ int y, /* Breite des neuen Grafikrechtecks*/ int width, /* Höhe des neuen Grafikrechtecks*/ int height);
//Teilt einen Spieler einem neuen Team zu. Es wird geprüft, ob in dem neuen Team noch Platz ist (anhand des MaxPlayer-Werts).
global func int SetPlayerTeam(/* Spielernummer des Spieler, dessen Team geändert werden soll.*/ int player, /* Teamnummer des neuen Teams.*/ int new_team, /* Wenn <code>true<code/>, werden die Aufrufe "RejectTeamSwitch" und "OnTeamSwitch" nicht getätigt. Der Spieler wird auch nicht neu verfeindet (dies muss ggf. selbst nachgeholt werden).*/ bool no_calls);
//Deaktiviert oder aktiviert gesperrte Sicht für einen oder alle Spieler. Falls die Sicht gesperrt wird kann der Spieler nicht umherscrollen um die Karte zu erkunden.
global func bool SetPlayerViewLock(/* Spieler, dessen Sichtsperre aktiviert oder deaktiviert werden soll. NO_OWNER für alle Spieler.*/ int player, /* Ob die Sicht gesperrt (true) oder entsperrt (false) werden soll.*/ bool locked);
//Deaktiviert oder aktiviert gesperrte Sicht für einen oder alle Spieler. Falls die Sicht gesperrt wird kann der Spieler nicht umherscrollen um die Karte zu erkunden.
global func bool SetPlayerZoomByViewRange(/* Spieler, dessen Zoom oder Zoomgrenzen angepasst werden sollen. NO_OWNER für alle Spieler.*/ int player, /* Horizontale Entfernung die vom Zoom abgedeckt wird. Null um nur range_y zu benutzen. Falls range_x und range_y null sind, wird eine vorgegebene Entfernung für range_x angenommen.*/ int range_x, /* Vertikale Entfernung die vom Zoom abgedeckt wird. Null um nur range_x zu benutzen. Falls range_x und range_y ungleich null sind, wird die Zahl genutzt die den kleineren Zoom.*/ int range_y, /* Flags controlling function behaviour:
            <table>
              <rowh>
                <col>Wert<col/>
                <col>Beschreibung<col/>
              <rowh/>
              <row>
                <literal_col>PLRZOOM_Direct<literal_col/>
                <col>Der Zoom scrollt nicht sanft zum neuen Wert, sondern wird direkt gesetzt.<col/>
              <row/>
              <row>
                <literal_col>PLRZOOM_NoIncrease<literal_col/>
                <col>Die neuen Zoomwerte sollen nur gesetzt werden, wenn sie kleiner als die aktuellen Werte sind.<col/>
              <row/>
              <row>
                <literal_col>PLRZOOM_NoDecrease<literal_col/>
                <col>Die neuen Zoomwerte sollen nur gesetzt werden, wenn sie größer als die aktuellen Werte sind.<col/>
              <row/>
              <row>
                <literal_col>PLRZOOM_LimitMin<literal_col/>
                <col>Setzt das minimale Grenze für den Zoom. Der Spieler kann nicht weiter herauszoomen als dieser Wert.<col/>
              <row/>
              <row>
                <literal_col>PLRZOOM_LimitMax<literal_col/>
                <col>Setzt das maximale Grenze für den Zoom. Der Spieler kann nicht weiter hineinzoomen als dieser Wert.<col/>
              <row/>
            <table/>
          */ int flags);
//Setzt die Liste der Musikstücke, die in zufälliger Reihenfolge abgespielt werden sollen (wenn die Musik aktiviert ist). Zurückgegeben wird die Anzahl der aktivierten Musikstücke (Im Netzwerk wird allerdings immer 0 zurückgegeben).
global func int SetPlayList(/* List of pieces of music to be played. The individual file names are separated with semicolons (";"). Wildcards are expanded.  If the parameter is left out, the standard playlist is restored.*/ string playlist);
//Mithilfe dieses Befehls können beliebige, scriptdefinierte Werte unter einem gegebenen Namen in der Spielerdatei gespeichert werden. Auf diese Weise kann man Daten über einen Spieler über Szenariogrenzen hinweg erhalten (z.B. für RPGs) Zurückgegeben wird (wenn erfolgreich) der gesetzte Wert.
global func any SetPlrExtraData(/* Nummer des Spielers, für den zusätzliche Daten gespeichert werden sollen*/ int player, /* Name der zugeordneten Daten.*/ string data_name, /* Daten, die gesetzt werden sollen.*/ Data);
//Fügt einen Bauplan zum Wissen des Spielers hinzu (oder entfernt ihn bei angegebenem remove).
global func int SetPlrKnowledge(/* Spieler, dem ein Bauplan gegeben werden soll*/ int player, /* ID der Objektdefinition, für die der Bauplan gegeben werden soll*/ id definition, /* Wenn ungleich <code>false<code/>, wird der Bauplan vom Wissen des Spielers entfernt*/ bool remove);
//Fügt einen Zauber der Liste der verfügbaren Zauber eines Spielers hinzu oder entfernt einen Zauber aus der Liste.
global func int SetPlrMagic(/* Nummer des Spielers, dessen Liste der verfügbaren Zauber geändert werden soll*/ int player, /* ID des Zaubers*/ id id, /* Ob der Zauber entfernt werden soll*/ bool remove);
//Zentriert das Sichtfenster eines Spielers auf ein Objekt. Die Sicht folgt dem Objekt bis zum nächsten Spielerkommando.
global func bool SetPlrView(/* Spieler, dessen Sicht gesetzt werden soll.*/ int player, /* Objekt, auf das die Sicht gesetzt werden soll.*/ object obj);
//Setzt die Sichtweite des aufrufenden Objekts.
global func any SetPlrViewRange(/* Sichtweite in Pixel.*/ int range);
//Verschiebt das aufrufende Objekt an die angegebene Position. Dabei wird das Objekt an die exakte Pixelposition gesetzt, und eventuelle, interne Verschiebungen um Pixelbruchteile werden verworfen.
global func any SetPosition(/* Neue X-Position für das Objekt*/ int x, /* Neue Y-Position für das Objekt*/ int y, /* Nur wirksam für Objekte mit angegebenem BorderBound. Stellt sicher, dass die Position immer innerhalb der dem Objekt auferlegten Grenzen ist.*/ bool check_bounds);
//Setzt die Eigenschaft <code>key<code/> von <code>obj<code/> auf <code>value<code/>. Die Eigenschaft muss vorher nicht existiert haben.
global func bool SetProperty(/* Zu setzende Eigenschaft.*/ string key, /* Wert, auf den die Eigenschaft gesetzt werden soll.*/ value, /* Objekt, das geändert wird. <code>nil<code/> bei lokalem Aufruf.*/ proplist obj);
//Setzt die Drehung des aufrufenden Objekts.
global func bool SetR(/* Winkel in Grad*/ int angle);
//Setzt die Drehungsgeschwindigkeit des aufrufenden Objekts.
global func bool SetRDir(/* Rotationsgeschwindigkeit geteilt durch precision*/ int rdir, /* Genauigkeit. Keine Angabe entspricht 10.*/ int precision);
/*

      Sets a single color value of a 32 bit color value. 
      <table>
        <rowh>
          <literal_col>select<literal_col/>
          <col>Auswahl<col/>
        <rowh/>
        <row>
          <literal_col>0<literal_col/>
          <col>Alpha-Wert<col/>
        <row/>
        <row>
          <literal_col>1<literal_col/>
          <col>Rotanteil<col/>
        <row/>
        <row>
          <literal_col>2<literal_col/>
          <col>Grünanteil<col/>
        <row/>
        <row>
          <literal_col>3<literal_col/>
          <col>Blauanteil<col/>
        <row/>
      <table/>

    
*/
global func int SetRGBaValue(/* 32Bit-Farbwert*/ int Val, /* 0-255: Farbwert, der mit dem alten ersetzt werden soll.*/ int NewVal, /* 0-3: Farbwert, der geändert werden soll*/ int select);
//Setzt Daten im Scoreboard. Das Scoreboard ist eine globale Tabelle, die Szenarien nutzen können um zum Beispiel den aktuellen Punktestand aller Spieler oder sonstige Rundendaten darzustellen. Es wird vom Spieler standardgemäß mit der Taste Tab aufgerufen, kann aber auch per Script mit <funclink>DoScoreboardShow<funclink/> forciert gezeigt oder verborgen werden.<br><br/> Das Scoreboard wird automatisch erstellt, sobald Daten darin gesetzt werden. Es wird automatisch gelöscht, wenn es außer Überschriften keine Daten mehr enthält.<br><br/> Daten werden über einen Zeilen- und Spaltenindex adressiert. Werte mit gleichem Zeilenindex landen in der gleichen Zeile; Werte mit gleichem Spaltenindex in der gleichen Spalte. Existieren noch keine Daten für einen Zeilen- bzw. Spaltenindex, so wird die Zeile bzw. Spalte neu angelegt und unten bzw. rechts angehängt. Es ist also nicht entscheidend, welche Indizes verwendet werden, solange sie eindeutig sind. Es können z.B. Spielernummern, Spieler-IDs (siehe <funclink>GetPlayerID<funclink/>) oder Team-IDs (siehe <funclink>GetPlayerTeam<funclink/>) angegeben werden. Damit mehrere Objektdefinitionen wie zum Beispiel ein Todeszähler nicht dieselben IDs für Spalten verwenden, gibt es die Funktion <funclink>ScoreboardCol<funclink/>, die aus einer ID einen eindeutige Spaltenindex generiert. Dabei ist natürlich trotzdem darauf zu achten, dass mehrere solcher Objekte die gleichen Zeilenadressierungen verwenden. Indizes müssen nicht fortlaufend sein; Zeilen und Spalten werden nach Reihenfolge des Hinzufügens und nicht nach Indizes sortiert. Für benutzerdefinierte Sortierungen (zum Beispiel absteigend nach Punkten für eine Bestenliste) dient die Funktion <funclink>SortScoreboard<funclink/>.
global func bool SetScoreboardData(/* Wert größer oder gleich 0, oder SBRD_Caption. Index der Zeile, dessen Daten gesetzt werden sollen. Die Konstante SBRD_Caption steht dabei für die erste Spalte, die als Spaltenbeschriftung verwendet werden sollte.*/ int row_id, /* Wert größer oder gleich 0, oder SBRD_Caption. Index der Spalte, dessen Daten gesetzt werden sollen. Die Konstante SBRD_Caption steht dabei für die erste Zeile, die als Zeilenüberschrift verwendet werden sollte.*/ int coloumn_id, /* Zu setzender Zellentext. Wenn 0 oder nicht angegeben, wird die Zelle ausgeleert. Sind in einer Zeile alle Zellen bis auf die Überschrift (Index SBRD_Caption) leer, wird diese Zeile komplett entfernt. Selbiges gilt für Spalten. Die Überprüfung auf leere Zeilen und Spalten wird immer nur dann durchgeführt, wenn eine Zelle ausgeleert wird.<br><br/>Um Text in anderen Farben darzustellen oder Symbole im Scoreboard einzufügen, sollte entsprechendes Markup verwendet werden.*/ string text, /* Zusatzdaten für diese Zellen. Nach diesen Daten wird das Scoreboard mit <funclink>SortScoreboard<funclink/> sortiert.*/ int data);
//Setzt die Jahreszeit.
global func any SetSeason(/* Jahreszeit von 0 (Frühling) bis 100 (Winter).*/ int season);
//Ändert das interne Objektrechteck des aufrufenden Objekts. Das Objektrechteck wird beispielsweise für Kollisionsabfragen verwendet. Dies hat keine Auswirkung auf die Darstellung des Objekts.
global func any SetShape(/* X-Offset des neuen Shapes*/ int x, /* Y-Offset des neuen Shapes*/ int y, /* Breite des neuen Shapes*/ int width, /* Höhe des neuen Shapes*/ int height);
//Setzt die Himmelsmodulation. Die Himmelsfarben werden mit der angegebenen Farbe so verrechnet wie auch ColorByOwner-Grafiken.
global func bool SetSkyAdjust(/* Primäre Farbmodulation*/ int colorMod, /* Hintergrundfarbe. Wenn in colorMod das Alphabyte nicht 0 ist, wird diese Farbe als Hintergrund hinter den Himmel gelegt. So lassen sich auch hellere oder entsättigte Himmel realisieren.*/ int backgroundColor);
//Verändert Parallaxität und Scrollgeschwindigkeit des Himmels.
global func bool SetSkyParallax(/* Scrollmodus. 0 ist Standard; bei 1 bewegt sich der Himmel mit dem Wind.*/ int mode, /* Parallaxität in X-Richtung. Bei 10 ist der Himmel fest an der Landschaft und erscheint daher auf dem selben Level wie die Landschaft selber. Größere Werte lassen den Himmel weiter vom Betrachter weg erscheinen.*/ int xpar, /* Parallaxität in Y-Richtung*/ int ypar, /* Feste, horizontale Bewegungsgeschwindigkeit des Himmels*/ int xdir, /* Feste, vertikale Bewegungsgeschwindigkeit des Himmels*/ int ydir, /* X-Scrollposition des Himmels*/ int x, /* Y-Scrollposition des Himmels*/ int y);
//Setzt einen neuen, festen Bereich eines Objekts. Das Quellrechteck der Grafik gibt dabei an, welche Pixel im Rechteck fest werden sollen: Alle Pixel, die zu weniger als 50% transparent sind, werden fest. Siehe auch Eintrag SolidMask in der <emlink>DefCore.txt<emlink/>.
global func any SetSolidMask(/* X-Position der oberen linken Ecke der neuen SolidMask in der Definitionsgrafik*/ int x, /* Y-Position der oberen linken Ecke der neuen SolidMask in der Definitionsgrafik*/ int y, /* Breite der neuen SolidMask in der Definitionsgrafik*/ int width, /* Höhe der neuen SolidMask in der Definitionsgrafik*/ int height, /* X-Zielposition der neuen SolidMask relativ zur oberen linken Objektecke*/ int target_x, /* Y-Zielposition der neuen SolidMask relativ zur oberen linken Objektecke*/ int target_y);
//Setzt die Geschwindigkeit des Objekts.
global func bool SetSpeed(/* Horizontale Gechwindigkeit geteilt durch precision.*/ int xdir, /* Vertikale Gechwindigkeit geteilt durch precision.*/ int ydir, /* Genauigkeit. Keine Angabe entspricht 10.*/ int precision);
//Setzt die globale Temperatur.
global func any SetTemperature(/* Temperatur von -100 bis 100.*/ int temperature);
//Setzt einen neuen Transferbereich für das aufrufende Objekt. Führt die Suche der Wegfindung durch einen Transferbereich (dieser gilt für die Wegfindung immer als komplett durchlaufbar), werden für den Clonk ControlTransfer-Aufrufe an das Script des Objekts aufgerufen. In diesen sollte mit Hilfe von Befehlen dafür gesorgt werden, dass der Clonk an seine Zielposition kommt.
global func bool SetTransferZone(/* X-Position der oberen linken Ecke der neuen Transferzone; relativ zum Objektmittelpunkt*/ int x, /* Y-Position der oberen linken Ecke der neuen Transferzone; relativ zum Objektmittelpunkt*/ int y, /* Breite der neuen Transferzone*/ int width, /* Höhe der neuen Transferzone*/ int height);
//Setzt eine Koordinate des indizierten Vertex (siehe <emlink>DefCore.txt<emlink/>) eines Objekts. Koordinaten in Relation zur Objektmitte.
global func int SetVertex(/* Index des Vertex.*/ int index, /* 
            Determines which vertex data is to be changed. 
            <table>
              <rowh>
                <col>Wert<col/>
                <col>Bedeutung<col/>
              <rowh/>
              <row>
                <col>VTX_X<col/>
                <col>X-Koordinate des Vertex.<col/>
              <row/>
              <row>
                <col>VTX_Y<col/>
                <col>Y-Koordinate des Vertex.<col/>
              <row/>
              <row>
                <col>VTX_CNAT<col/>
                <col><emlink>CNAT-Wert<emlink/> des Vertex.<col/>
              <row/>
              <row>
                <col>VTX_Friction<col/>
                <col>Reibung des Vertex.<col/>
              <row/>
            <table/>

          */ int select, /* Wert, auf den gesetzt werden soll.*/ int value, /* Wenn 1 oder 2, wird der Wert in den hinteren 25 Vertices gesetzt und aus diesen beim nächsten Shape-Update kopiert. Mit diesem Parameter kann dafür gesorgt werden, dass benutzerdefinierte Vertices auch bei rotierten Objekten erhalten bleiben. Bei Wert 2 werden die gegenwärtigen Objektvertices auch gleich aktualisiert.*/ int set_custom_permanent);
//Setzt X und Y eines Vertices zugleich
global func bool SetVertexXY(/* Vertexnummer*/ int index, /* Gewünschte X-Position des Vertices*/ int xpos, /* Gewünschte Y-Position des Vertices*/ int ypos);
//Verschiebt die Sicht eines Spielers permanent um einen bestimmten Betrag. Ein erneuter Aufruf überschreibt die Verschiebung wieder, ein Aufruf mit 0-Koordinaten setzt die Sicht wieder in den Normalzustand zurück.
global func bool SetViewOffset(/* Spieler, für den der Sicht-Offset gesetzt werden soll.*/ int player, /* X-Komponente des Offsets (in Pixel).*/ int x, /* Y-Komponente des Offsets (in Pixel).*/ int x);
//Setzt das Vermögen eines Spielers.
global func bool SetWealth(/* Spielernummer des Spielers, dessen Vermögen verändert werden soll*/ int player, /* Das neue Vermögen.*/ int value);
//Setzt die globale Windrichtung und -stärke.
global func any SetWind(/* Windstärke von -100 bis 100.*/ int strength);
//Setzt die horizontale Geschwindigkeit des aufrufenden Objekts.
global func bool SetXDir(/* Horizontale Gechwindigkeit geteilt durch precision.*/ int xdir, /* Genauigkeit. Keine Angabe entspricht 10.*/ int precision);
//Setzt die vertikale Geschwindigkeit des Objekts.
global func bool SetYDir(/* Vertikale Gechwindigkeit geteilt durch precision.*/ int ydir, /* Genauigkeit. Keine Angabe entspricht 10.*/ int precision);
//Löst innerhalb eines kreisförmigen Bereiches halbfestes Material in der Landschaft. Für gelöstes Material wird neu geprüft, ob es in darunterliegendes Material fallen kann. Dadurch kann man zum Beispiel Höhlendecken einstürzen lassen.
global func any ShakeFree(/* X-Mittelposition des freigeschüttelten Kreises. Immer global.*/ int x, /* Y-Mittelposition des freigeschüttelten Kreises. Immer global.*/ int y, /* Radius des freigeschüttelten Kreises*/ int radius);
//Schüttelt innerhalb eines kreisförmigen Bereiches alle Lebewesen durch. Dieses Verhalten ist vergleichbar mit <funclink>Fling<funclink/>()-Aufrufen mit kleinen Zufallswerten auf alle Objekte im Zielbereich.
global func any ShakeObjects(/* X-Mittelposition des durchgeschüttelten Kreises. Immer global.*/ int x, /* Y-Mittelposition des durchgeschüttelten Kreises. Immer global.*/ int y, /* Radius des durchgeschüttelten Kreises*/ int radius);
//Sortiert die Inhaltsobjekte des aufrufenden Objekts so um, dass das nächste Objekt mit anderer ID vorne liegt. Die häufigste Anwendung für diesen Befehl ist ein Inventarwechsel.
global func bool ShiftContents(/* Wenn wahr, wird rückwärts durchsortiert.*/ bool shift_back, /* ID des Objekttyps, der als nächstes ausgewählt sein soll. Wenn dieser Parameter angegeben ist, wird kein ControlContents-Aufruf mehr getätigt, sondern es wird direkt und ohne das Abspielen eines Sounds durchgeschaltet. Damit lässt sich beispielsweise das Durchschalten des Inventars in ControlConents überladen, und mit eigenen Sounds oder Zusatzaktivitäten versehen.*/ id target_id, /* Wenn wahr, werden ControlContents- und Selection-Aufrufe getätigt.*/ bool no_calls);
//Zeigt die Beschreibung eines Objekts in einem kleinen Informationsfenster (intern ein Menü) beim aufrufenden Objekt an.
global func bool ShowInfo();
//Simuliert die Bewegung eines fallenden Objekts mit einer gegebenen Startposition und initialier Geschwindigkeit. Das zurückgegebene Array enthält [int x_final, int y_final, int xdir_final, int ydir_final, int time_passed]. <br><br/> Falls die projektierte Flugbahn ein Material der angegebenen Dichte trifft wird die Simulation gestoppt und time_passed wird nicht negativ. Ansonsten wird time_passed negativ.
global func array SimFlight(/* X-Versatz der Startposition. (NICHT optional wenn ohne Objektkontext aufgerufen wird)*/ int x, /* Y-Versatz der Startposition. (NICHT optional wenn ohne Objektkontext aufgerufen wird)*/ int y, /* Initiale horizontale Geschwindigkeit. Falls nicht gesetzt, wird die horizontale Geschwindigkeit des Objekts angenommen. (NICHT optional wenn ohne Objektkontext aufgerufen wird)*/ int xdir, /* Initiale vertikale Geschwindigkeit. Falls nicht gesetzt, wird die vertikale Geschwindigkeit des Objekts angenommen. (NICHT optional wenn ohne Objektkontext aufgerufen wird)*/ int ydir, /* Minimale Dichte des Materials nach dem auf der Wurfbahn gesucht wird. Keine Angabe entspricht 50 (festes Material).*/ int min_density, /* Maximale Dichte des Materials nach dem auf der Wurfbahn gesucht wird. Keine Angabe entspricht 100.*/ int max_density, /* Anzahl der simulierten Frames bis zum Abbruch der Simulation. Keine Angabe oder ein negativer Wert bedeutet dass solange gesucht wird bis die Landschaft oder der Rand der Landkarte getroffen wird.*/ int iterations, /* Genauigkeit. Keine Angabe entspricht 10.*/ int precision);
//Liefert sin(angle) * radius.
global func int Sin(/* Winkel in Grad*/ int angle, /* Radius*/ int radius, /* Der angegebene Winkel wird, wenn angegeben, vor der Berechnung durch diesen Wert dividiert. Bei einem Winkel von 455 und einer Präzision von 10 würde intern also mit einem Winkel von 45,5° gerechnet werden.*/ int precision);
//Erzeugt eine Rauchwolke an der angegebenen Position.
global func bool Smoke(/* X-Position der Rauchwolke. Offset bei lokalem Aufruf.*/ int x, /* Y-Position der Rauchwolke. Offset bei lokalem Aufruf.*/ int y, /* Größe des Rauchs*/ int level);
//Sortierkriterium: Sortiert die gefundenen Objekte nach Entfernung zum angegebenen Bezugspunkt. Die nahesten Objekte zuerst.
global func array Sort_Distance(/* Bezugspunkt für den Abstand. Bei lokalem Aufruf Offset zum aufrufenden Objekt.*/ int x, /* Bezugspunkt für den Abstand. Bei lokalem Aufruf Offset zum aufrufenden Objekt.*/ int y);
//Sortierkriterium: Sortiert die gefundenen Objekte anhand des int-Rückgabewertes der angegebenen Funktion. Je kleiner der Wert, desto weiter vorne steht das Objekt im Array.
global func array Sort_Func(/* Aufzurufende Funktion*/ string function);
//Sortierkriterium: Sortiert die gefundenen Objekte nach ihrer Masse. Die leichtesten Objekte zuerst.
global func array Sort_Mass();
//Sortierkriterium: Erlaubt es nach mehreren Kriterien zu sortieren. Das erste Kriterium hat dabei die höchste Priorität.
global func array Sort_Multiple(/* Sortierkriterium in Form einer Sort_*-Funktion*/ array Criteria);
//Sortierkriterium: Sortiert die gefundenen Objekte zufällig.
global func array Sort_Random();
//Sortiermodifikator: Kehrt die Sortierung der angegebenen Sortierfunktion um.
global func array Sort_Reverse(/* Sortierfunktion*/ array iSort);
//Sortierkriterium: Sortiert die gefundenen Objekte nach Geschwindigkeit. Die langsamsten Objekte zuerst.
global func array Sort_Speed();
//Sortierkriterium: Sortiert die gefundenen Objekte nach ihrem Wert. Die wertlosesten Objekte zuerst.
global func array Sort_Value();
//
global func bool SortArray(/* Array, dessen Länge verändert werden soll*/ array array2sort, /* Wenn wahr, wird in absteigender Reihenfolge sortiert. Ansonsten in aufsteigender Reihenfolge.*/ bool descending);
//
global func bool SortArrayByArrayElement(/* Array, dessen Länge verändert werden soll*/ array array2sort, /* */ int element_index, /* Wenn wahr, wird in absteigender Reihenfolge sortiert. Ansonsten in aufsteigender Reihenfolge.*/ bool descending);
//
global func bool SortArrayByProperty(/* Array, dessen Länge verändert werden soll*/ array array2sort, /* [opt] Variable, in der der Rotanteil gespeichert werden soll*/ string property_name, /* Wenn wahr, wird in absteigender Reihenfolge sortiert. Ansonsten in aufsteigender Reihenfolge.*/ bool descending);
//Sortiert die Zeilen des Scoreboards nach den Extradaten einer Spalte. Wenn zwei Einträge in dieser Spalte die gleichen Werte besitzen, wird nicht umsortiert. So kann durch sukzessive Aufrufe dieser Funktion nach mehreren Spalten sortiert werden.
global func bool SortScoreboard(/* ID der Spalte, nach der sortiert werden soll.*/ int coloumn_id, /* Wenn wahr, wird in absteigender Reihenfolge sortiert. Ansonsten in aufsteigender Reihenfolge.*/ bool reverse);
//Spielt einen Sound ab. Die entsprechende Sounddatei muss in der Gruppendatei Sound.ocg, in der aktiven Szenariodatei oder in einer geladenen Objektdefinition vorhanden sein. Bei lokalen Aufrufen werden Geräusche abhängig von der aktuellen Position des aufrufenden Objekts abgespielt.
global func bool Sound(/* Name des Soundeffekts (ohne .wav/.ogg-Erweiterung). Wildcards dürfen wie in <funclink>WildcardMatch<funclink/> verwendet werden*/ string name, /* Gibt an, ob der Sound global, d.h. unabhängig von der Objektposition immer in derselben Lautstärke abgespielt werden soll.*/ bool global, /* 0-100: Lautstärke, in der der Sound abgespielt wird. Bei <code>nil<code/> wird 100 als Standard angenommen.*/ int volume, /* Spielernummer des Spielers, für den der Sound abgespielt werden soll. Im Netzwerkspiel wird der Sound dann nicht bei einem Spieler abgespielt, der an einem anderen Rechner spielt. Wenn <code>nil<code/> oder nicht angegeben, wird der Sound für alle Spieler abgespielt.*/ int player, /* Erhöht oder verringert die Anzahl der in einer Endlosschleife laufenden Sounds. Bei +1 wird dieser Sound unendlich oft abgespielt bis diese Funktion noch einmal mit -1 aufgerufen wird. Bei 0 wird der Sound normal abgespielt.*/ int loop_count);
//Zerlegt ein Objekt in seine Bestandteile. Die Bestandteile werden in zufälliger Drehung und mit geringer Geschwindigkeit in zufälliger Richtung an der Stelle erzeugt, an der sich das Objekt befand. Das Objekt wird anschließend vernichtet. Wenn sich das Objekt in einem Behälter befand, werden auch die Komponenten nach der Erschaffung in den Behälter versetzt.
global func bool Split2Components();
//Gibt ein Array mit dem Rot-, Grün-, Blau- und Alpha-Wertes des angegebenen 32Bit-Farbwerts zurück: [Rot, Grün, Blau, Alpha]
global func array SplitRGBaValue(/* 32Bit-Farbwert*/ int rgba);
//Zieht die Wurzel aus dem ersten Parameter. Ist der Parameter kleiner als 0, wird einfach 0 zurückgegeben.
global func int Sqrt(/* Wert, aus dem die Wurzel gezogen werden soll*/ int value);
//Startet den Scriptprofiler.
global func bool StartScriptProfiler(/* Wenn angegeben, werden nur Scriptfunktionen einer bestimmten Objektdefinition gemessen.*/ id definition_script);
//Stoppt die Animation mit der angegeben Nummer (wie sie von <funclink>PlayAnimation<funclink/> zurückgegeben wird) und entfernt die Animation aus dem zugehörigen Slot im Animations-Stack. Gehört ein Kombinationsknoten zur Nummer, so werden beide Animationen entfernt die kombiniert werden; wenn eine oder beide davon wieder Kombinationen sind werden auch deren Animationen entfernt, und so weiter. Wird die gestoppte Animation mit einer anderen kombiniert, so wird auch der zugehörige Kombinationsknoten entfernt, da es nun nichts mehr zu kombinieren gibt. Gibt <code>true<code/> zurück wenn die Animation entfernt wurde, oder <code>false<code/> wenn dies nicht möglich war (zum Beispiel wenn es keine Animation zur gegebenen Nummer gibt, oder die Animation zu Slot 0 gehört).
global func bool StopAnimation(/* Nummer der zu stoppenden Animation.*/ int animation_number);
//Stoppt den Scriptprofiler, und gibt das Ergebnis im Log aus.
global func bool StopScriptProfiler();
//Ermittelt, ob das aufrufende Objekt feststeckt, d.h., ob sich einer seiner Vertices in festem Material befindet.
global func bool Stuck();
//Liefert tan(angle) * radius.
global func int Tan(/* Winkel in Grad*/ int angle, /* Radius*/ int radius, /* Der angegebene Winkel wird, wenn angegeben, vor der Berechnung durch diesen Wert dividiert. Bei einem Winkel von 455 und einer Präzision von 10 würde intern also mit einem Winkel von 45,5° gerechnet werden.*/ int precision);
//Gibt die neue Bitmaske mit dem an der angegebenen Stelle umgedrehten Bit zurück
global func int ToggleBit(/* Alter Wert der Bitmaske*/ int old_value, /* Das umzudrehende Bit*/ int bit_number);
//Liefert eine 3x4-Einheitsmatrix. Sie kann als Transformation für <funclink>AttachMesh<funclink/> oder für die "PictureTransformation" oder "MeshTransformation"-Eigenschaften (siehe <emlink>Meshes<emlink/>) verwendet werden.
global func array Trans_Identity();
//Multipliziert zwei oder mehr 3x4-Transformationsmatrizen in der gegegebenen Reihenfolge. Somit können die Effekte mehrerer Transformationen miteinander kombiniert werden. Das Ergebnis kann als Transformation für <funclink>AttachMesh<funclink/> oder für die "PictureTransformation" oder "MeshTransformation"-Eigenschaften (siehe <emlink>Meshes<emlink/>) verwendet werden.
global func array Trans_Mul(/* Erste Matrix wie von <funclink>Trans_Identity<funclink/>, <funclink>Trans_Translate<funclink/>, <funclink>Trans_Rotate<funclink/> oder <funclink>Trans_Scale<funclink/> zurückgegeben.*/ array first, /* Zweite Matrix.*/ array second);
//Liefert eine 3x4-Rotationsmatrix welche eine Drehung um die Achse (<code>rx<code/>, <code>ry<code/>, <code>rz<code/>) um <code>angle<code/> Grad beschreibt. Sie kann als Transformation für <funclink>AttachMesh<funclink/> oder für die "PictureTransformation" oder "MeshTransformation"-Eigenschaften (siehe <emlink>Meshes<emlink/>) verwendet werden.
global func array Trans_Rotate(/* Drehwinkel. Positive Werte drehen entgegen dem Uhrzeigersinn wenn man in Richtung der Drehachse blickt, negative Werte drehen im Uhrzeigersinn.*/ int angle, /* X-Koordinate der Drehachse.*/ int rx, /* Y-Koordinate der Drehachse.*/ int ry, /* Z-Koordinate der Drehachse.*/ int rz);
//Liefert eine 3x4-Skalierungsmatrix. Sie kann als Transformation für <funclink>AttachMesh<funclink/> oder für die "PictureTransformation" oder "MeshTransformation"-Eigenschaften (siehe <emlink>Meshes<emlink/>) verwendet werden.
global func array Trans_Scale(/* Vergrößerung in X-Richtung.*/ int sx, /* Vergrößerung in Y-Richtung.*/ int sy, /* Vergrößerung in Z-Richtung.*/ int sz);
//Liefert eine 3x4-Verschiebungsmatrix. Sie kann als Transformation für <funclink>AttachMesh<funclink/> oder für die "PictureTransformation" oder "MeshTransformation"-Eigenschaften (siehe <emlink>Meshes<emlink/>) verwendet werden.
global func array Trans_Translate(/* Verschiebung in X-Richtung.*/ int dx, /* Verschiebung in Y-Richtung.*/ int dy, /* Verschiebung in Z-Richtung.*/ int dz);
//Schlägt einen Text in der <emlink>StringTbl??.txt<emlink/> des aufrufenden Skripts nach, und gibt die Übersetzung zurück.
global func string Translate(/* Zeichenkette, die übersetzt werden soll*/ string text);
//Liefert die Anzahl feststeckender Vertices von *obj
global func int VerticesStuck(/* Zielobjekt*/ object obj);
//Prüft, ob zwei Strings gleich sind. Die Prüfung beachtet Groß- und Kleinschreibung, außerdem können Wildcards benutzt werden.
global func string WildcardMatch(/* String, der überprüft werden soll.*/ string text, /* String, der überprüft werden soll.*/ string wildcard);
//
global func any CreatePropList(prototype);
global func any ResetProperty(key, pObj);
//
global func any DebugLog(Pars);
//
global func any AsyncRandom(int iRange);
//
global func any LocateFunc(funcname, p);
//
global func any ModulateColor(int iClr1, int iClr2);
//
global func any StartCallTrace();
global func any GetConstantNameByValue(int value, name_prefix, int idx);
//
global func any IncinerateLandscape(int iX, int iY);
global func any GetPlayerColor(int iPlayer);
//
global func any GetTexture(int x, int y);
global func any GetAverageTextureColor(string Texture);
//
global func any BlastFree(int iX, int iY, int iLevel, int iCausedBy);
//
global func any AddMessage(Pars);
//
global func any ResetCursorView(int plr);
//
global func any SurrenderPlayer(int iPlr);
//
global func any SetLeaguePerformance(int iScore);
//
global func any GetViewCursor(int iPlr);
//
global func any SetViewCursor(int iPlr, pObj);
global func any ClearFreeRect(int iX, int iY, int iWdt, int iHgt);
//
global func any PathFree2(x1, y1, x2, y2);
//
global func any GetLeague(int idx);
//
global func any TestMessageBoard(int iForPlr, bool fTestIfInUse);
//
global func any CallMessageBoard(pObj, bool fUpperCase, szQueryString, int iForPlr);
//
global func any AbortMessageBoard(pObj, int iForPlr);
//
global func any OnMessageBoardAnswer(pObj, int iForPlr, szAnswerString);
//
global func any GetMatAdjust();
//
global func any DrawMatChunks(int tx, int ty, int twdt, int thgt, int icntx, int icnty, strMaterial, strTexture, bool bIFT);
global func any CastAParticles(szName, int iAmount, int iLevel, int iX, int iY, int a0, int a1, int b0, int b1, pObj, bool fBack);
//
global func any CastBackParticles(szName, int iAmount, int iLevel, int iX, int iY, int a0, int a1, int b0, int b1, pObj);
//
global func any SetTextureIndex(psMatTex, int iNewIndex, bool fInsert);
//
global func any RemoveUnusedTexMapEntries();
//
global func any LoadScenarioSection(pstrSection, int dwFlags);
//
global func any SetPreSend(int iToVal, pNewName);
//
global func any GetTeamConfig(int iConfigValue);
//
global func any InitScenarioPlayer(int iPlayer, int idTeam);
//
global func any GetScoreboardString(int iRowID, int iColID);
//
global func any GetScoreboardData(int iRowID, int iColID);
//
global func any AddEvaluationData(pText, int idPlayer);
//
global func any HideSettlementScoreInEvaluation(bool fHide);
//
global func any ActivateGameGoalMenu(int iPlayer);
//
global func any PauseGame(bool fToggle);
//
global func any SetNextMission(szNextMission, szNextMissionText, szNextMissionDesc);
//
global func any GetPlayerControlState(int iPlr, int iControl);
//
global func any SetPlayerControlEnabled(int iplr, int ctrl, bool is_enabled);
global func any GetPlayerControlEnabled(int iplr, int ctrl);
//
global func any ExecuteCommand();
//
global func any SetMenuDecoration(idNewDeco);
//
global func any SetMenuTextProgress(int iNewProgress);
//
global func any GetObjectLayer();
//
global func any SetObjectLayer(pNewLayer);
//
global func any SetObjDrawTransform2(int iA, int iB, int iC, int iD, int iE, int iF, int iG, int iH, int iI, int iOverlayID);
//
global func any SetObjectStatus(int iNewStatus, bool fClearPointers);
//
global func any GetObjectStatus();
//
global func any AdjustWalkRotation(int iRangeX, int iRangeY, int iSpeed);
global func any DoNoCollectDelay(int change);
global func any this();

static const proplist MapLayer;
static const proplist Map;
static const int MAPALGO_Layer;
static const int MAPALGO_RndChecker;
static const int MAPALGO_And;
static const int MAPALGO_Or;
static const int MAPALGO_Xor;
static const int MAPALGO_Not;
static const int MAPALGO_Scale;
static const int MAPALGO_Offset;
static const int MAPALGO_Rect;
static const int MAPALGO_Ellipsis;
static const int MAPALGO_Polygon;
static const int MAPALGO_Turbulence;
static const int MAPALGO_Border;